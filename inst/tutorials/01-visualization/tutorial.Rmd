---
title: "Visualization"
tutorial:
  id: "01-visualization"
output: 
  learnr::tutorial:
    progressive: true
    allow_skip: true
author: Jessica Edwards
runtime: shiny_prerendered
description: "Gov 50: Data Chapter 1 Tutorial"
---

<!-- Ch. 1 tutorial questions written by Jessica Edwards, Connor Rust and Liam Rust  -->
<!-- Also includes questions from rstudio/learnr and rstudio-education/primers GitHub repos -->

```{r setup, include=FALSE}
library(tidyverse)
library(PPBDS.data)
library(learnr)
library(shiny)

library(ggthemes)
library(viridis)
library(nycflights13)

knitr::opts_chunk$set(echo = FALSE, message = FALSE)
options(tutorial.exercise.timelimit = 60, tutorial.storage="local")  
```

## Welcome!

Welcome to your first Gov 50 tutorial on Chapter 1: Visualization! We hope that this tutorial will be a great opportunity for you to learn and dive deeper into the course material. Most of these tutorial questions will be exercises in which you can put your coding skills to the test to practice all of the cool visualization techniques you read about in Chapter 1, but you will also test your knowledge in multiple choice and short answer questions. Let's get started!!

## How do I code in R?

R is easiest to use when you know how the R language works. Some of the basic programming topics in R include the following:

* **functions** and their **arguments**
* **objects**
* R's basic **data types** 
* R's basic data structures including **vectors** and **lists**
* R's **package system**

### Load a package

In the code chunk below, load the `tidyverse` package. Whenever you load a package R will also load all of the packages that the first package depends on. `tidyverse` takes advantage of this to create a shortcut for loading several common packages at once. Whenever you load `tidyverse`, `tidyverse` also loads `ggplot2`, `dplyr`, `tibble`, `tidyr`, `readr`, and `purrr`.

```{r packages2, exercise = TRUE}

```

### Quotes

Did you know, `library()` is a special function in R? You can pass `library()` a package name in quotes, like `library("tidyverse")`, or not in quotes, like `library(tidyverse)`---both will work! That's often not the case with R functions.

<!-- JSE - commented it out for now due to weird error, not sure how to remove "Run Code" button -->

<!-- ### Install packages -->

<!-- But what if the package that you want to load is not installed on your computer? How would you install the dplyr package on your own computer? -->

<!-- ```{r packages3, exercise = TRUE, exercise.eval = FALSE} -->

<!-- ``` -->

### 

Load the `ggplot2` package using `library()`.

```{r exercise-1, exercise = TRUE, exercise.lines = 3}

```

### Functions 

Can you use the `sqrt()` function in the chunk below to compute the square root of 962?

```{r functions-1, exercise = TRUE}

```

Use the code chunk below to examine the code that `sqrt()` runs.

```{r functions-2, exercise = TRUE}
sqrt
```

Compare the code in `sqrt()` to the code in another R function, `lm()`. Examine `lm()`'s code body in the chunk below.

```{r functions-3, exercise = TRUE}
lm
```

### help pages

Wow! `lm()` runs a lot of code. What does it do? Open the help page for `lm()` in the chunk below and find out.

```{r functions-4, exercise = TRUE}

```

### Code comments

What do you think the chunk below will return? Run it and see. The result should be nothing. R will not run anything on a line after a `#` symbol. This is useful because it lets you write human readable comments in your code: just place the comments after a `#`. Now delete the `#` and re-run the chunk. You should see a result.

```{r functions-5, exercise = TRUE}
# sqrt(961)
```

### Objects

#### Object names

You can choose almost any name you like for an object, as long as the name does not begin with a number or a special character like `+`, `*`, `-`, `/`, `^`, `!`, `@`, or `&`. 

```{r objects-1, echo = FALSE}
question("Which of these would be valid object names?",
  answer("today", correct = TRUE),
  answer("1st"),
  answer("+1"),
  answer("vars", correct = TRUE),
  answer("\\^_^"),
  answer("foo", correct = TRUE),
  allow_retry = TRUE,
  correct = "Remember that the most helpful names will remind you what you put in your object."
)
```

#### Using objects

In the code chunk below, save the results of `rnorm(100, mean = 100, sd = 15)` to an object named `data`. Then, on a new line, call the `hist()` function on `data` to plot a histogram of the random values.

```{r objects-2, exercise=TRUE}

```

#### What if?

What do you think would happen if you assigned `data` to a new object named `copy`, like this? Run the code and then inspect both `data` and `copy`.

```{r objects-3, exercise=TRUE}
data <- rnorm(100, mean = 100, sd = 15)
copy <- data
```

#### Data sets

Objects provide an easy way to store data sets in R. In fact, R comes with many toy data sets pre-loaded. Examine the contents of `iris` to see a classic toy data set. Hint: how could you learn more about the `iris` object?

```{r objects-4, exercise = TRUE}

```

#### A common error

```{r packages1, echo = FALSE}
question('What does this common error message suggest? `object _____ does not exist.`',
         answer("You misspelled your object name"),
         answer("You've forgot to load the package that ____ comes in"),
         answer("Either", correct = TRUE),
         allow_retry = TRUE)
```

### Vectors

#### Create a vector

In the chunk below, create a vector that contains the integers from one to ten.

```{r vectors-1, exercise = TRUE}

```

```{r vectors-1-hint, eval=FALSE}
c(...)
```

#### `:`

If your vector contains a sequence of contiguous integers, you can create it with the `:` shortcut. Run `1:10` in the chunk below. What do you get? What do you suppose `1:20` would return?

```{r vectors-2, exercise = TRUE}

```

#### `[]`

You can extract any element of a vector by placing a pair of brackets behind the vector. Inside the brackets place the number of the element that you'd like to extract. For example, `vec[3]` would return the third element of the vector named `vec`.

Use the chunk below to extract the fourth element of `vec`.

```{r vectors-3, exercise = TRUE}
vec <- c(1, 2, 4, 8, 16)
```

#### More `[]`

You can also use `[]` to extract multiple elements of a vector. Place the vector `c(1,2,5)` between the brackets below. What does R return?

```{r vectors-4, exercise = TRUE}
vec <- c(1, 2, 4, 8, 16)
vec[]
```

#### Names

If the elements of your vector have names, you can extract them by name. To do so place a name or vector of names in the brackets behind a vector. Surround each name with quotation marks, e.g. `vec2[c("alpha", "beta")]`.

Extract the element named gamma from the vector below.

```{r vectors-5, exercise = TRUE}
vec2 <- c(alpha = 1, beta = 2, gamma = 3)
```

#### Vectorised operations

Predict what the code below will return. Then look at the result.

```{r vectors-6, exercise = TRUE}
c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10) + c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
```

#### Vector recycling

Predict what the code below will return. Then look at the result.

```{r vectors-7, exercise = TRUE}
1 + c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
```

### Types

#### Data types
 
```{r flights3, echo = FALSE}
flights
``` 
 
Did you notice that a row of three (or four) letter abbreviations appears under the column names of `flights`? These abbreviations describe the _type_ of data that is stored in each column of `flights`:

* `int` stands for integers.

* `dbl` stands for doubles, or real numbers.

* `chr` stands for character vectors, or strings.

* `dttm` stands for date-times (a date + a time).

There are three other common types of variables that aren't used in this dataset but are used in other datasets:

* `lgl` stands for logical, vectors that contain only `TRUE` or `FALSE`.

* `fctr` stands for factors, which R uses to represent categorical variables
  with fixed possible values.

* `date` stands for dates.

This row of data types is unique to tibbles and is one of the ways that tibbles try to be more user-friendly than data frames.

#### Vectors

```{r types5, echo = FALSE}
question('How many types of data can you put into a single vector?',
         answer("1", correct = TRUE),
         answer("6"),
         answer("As many as you like"),
         allow_retry = TRUE)
```

#### Character or object?

One of the most common mistakes in R is to call an object when you mean to call a character string and vice versa.

```{r types6, echo = FALSE}
question('Which of these are object names? What is the difference between object names and character strings?',
         answer("foo", correct = TRUE),
         answer('"num"'),
         answer("mu", correct = TRUE),
         answer('"sigma"'),
         answer('"data"'),
         answer("a", correct = TRUE),
         allow_retry = TRUE,
         correct = "Character strings are surrounded by quotation marks, object names are not.")
```

### Lists 

#### Lists vs. vectors

```{r lists1, echo = FALSE}
question('Which data structure(s) could you use to store these pieces of data in the same object? `1001`, `TRUE`, `"stories"`.',
         answer("a vector"),
         answer("a list", correct = TRUE),
         answer("neither"),
         allow_retry = TRUE)
```

#### Make a list

Make a list that contains the elements `1001`, `TRUE`, and `"stories"`. Give each element a name.

```{r lists2, exercise = TRUE}

```

#### Extract an element

Extract the number 1001 from the list below.

```{r lists3, exercise = TRUE}
things <- list(number = 1001, logical = TRUE, string = "stories")
```

#### Data Frames

You can make a data frame with the `data.frame()` function, which works similar to `c()`, and `list()`. Assemble the vectors below into a data frame with the column names `numbers`, `logicals`, `strings`.

```{r lists4, exercise = TRUE}
nums <- c(1, 2, 3, 4)
logs <- c(TRUE, TRUE, FALSE, TRUE)
strs <- c("apple", "banana", "carrot", "duck")
```

#### Extract a column

Given that a data frame is a type of list (with named elements), how could you extract the strings column of the `df` data frame below? Do it.

```{r lists5, exercise = TRUE}
nums <- c(1, 2, 3, 4)
logs <- c(TRUE, TRUE, FALSE, TRUE)
strs <- c("apple", "banana", "carrot", "duck")
df <- data.frame(numbers = nums, logicals = logs, strings = strs)
```

## Exploring data frames

### `trains` dataset

Load the `PPBDS.data` package to look at the `trains` dataset.
```{r exercise-2, exercise = TRUE, exercise.lines = 5}

  
trains
```

Use the `glimpse()` function to look at the `trains` dataset. We already loaded the `tidyverse` and `PPBDS.data` packages.
```{r exercise-4, exercise = TRUE, exercise.lines = 5}
library(tidyverse)
library(PPBDS.data)


```

```{r quiz-4, echo = FALSE}
quiz(caption = "Quiz - `trains` dataset",
  question("What is the data type of the `liberal` variable?",
           answer("character"),
           answer("logical", correct = TRUE),
           answer("double"),
           answer("factor"),
           allow_retry = TRUE
  ),
  question("How many rows does the `train` dataset have?",
           answer("8"),
           answer("15"),
           answer("115", correct = TRUE),
           allow_retry = TRUE
  )
)
```

Extract the `income` variable in the `trains` dataset using the `$` operator.
```{r exercise-5, exercise = TRUE}

```

### `qscores` dataset

Look at the `qscores` dataset using `glimpse()`. We have loaded the `PPBDS.data` and the `tidyverse` packages.

```{r qscores, exercise = TRUE, exercise.lines = 5}

```

```{r quiz-5, echo = FALSE}
quiz(
  question("Which of the following is NOT an identification variable? (choose 2)",
           answer("`name`"),
           answer("`department`", correct = TRUE),
           answer("`workload`", correct = TRUE),
           answer("`number`"),
           allow_retry = TRUE
  )
)
```

## Grammar of graphics

```{r quiz-6, echo = FALSE}
quiz(
  question("What are the three essential components of a graphic?",
           answer("the dataset containing the variables in question", correct = TRUE),
           answer("the geometric object we can observe in a plot", correct = TRUE),
           answer("axes labels on a plot"),
           answer("the aesthetic attributes", correct = TRUE),
           allow_retry = TRUE
  ),
  question("What are the two important arguments that we need to provide the `ggplot()` function?",
           answer("`data` and `mapping`", correct = TRUE),
           answer("`data` and `aesthetics`"),
           answer("`data` and `layers`"),
           allow_retry = TRUE
  )
)
```

### Components of a scatterplot

Look at this scatterplot made using the `trains` dataset. Higher numbers mean more conservative attitudes toward immigration-related policies on a 3 to 15 scale. Individuals with a treatment value of "Treated" were exposed to two Spanish-speakers on their regular commute. "Control" individuals were not.

```{r trains}
ggplot(data = trains, mapping = aes(x = att_start, y = att_end, color = treatment)) +
  geom_point() + facet_wrap(~party)
```

```{r quiz-7, echo = FALSE}
quiz(
  question("Which `data` variable is mapped to the `x`-position `aes`thetic of the points?",
           answer("`att_start`", correct = TRUE),
           answer("`att_end`"),
           answer("`treatment`"),
           allow_retry = TRUE
  ),
  question("Which `data` variable is mapped to the `y`-position `aes`thetic of the points?",
           answer("`att_start`"),
           answer("`att_end`", correct = TRUE),
           answer("`treatment`"),
           allow_retry = TRUE
  ),
  question("Which `data` variable is mapped to the `color` `aes`thetic of the points?",
           answer("`att_start`"),
           answer("`att_end`"),
           answer("`treatment`", correct = TRUE),
           allow_retry = TRUE
  )
)
```

## `geom_point()` 
<!-- I -->

Let's make a scatterplot using the `iris` dataset. Hit the 'Run Code' button.

```{r gp-1-1, exercise=TRUE, eval=FALSE}
ggplot(data = iris, mapping = aes(x = Petal.Length, y = Petal.Width)) + 
  geom_point()
```

###

Great! Now try making a scatterplot with x = `Sepal.Length` and y = `Sepal.Width`.

```{r gp-1-2-hint, eval=FALSE}
ggplot(data = iris, mapping = aes(x = ..., y = ...)) + 
  geom_point()
```

```{r gp-1-2, exercise=TRUE, exercise.lines = 5}
  

```

###

Excellent work! Now let's make a scatterplot with `Sepal.Length` on the x-axis, and `Petal.Length` on the y-axis. 

```{r gp-1-3, exercise=TRUE, exercise.lines = 5}
  

```

Wonderful. Now use what you've learned to recreate the plot below.

```{r}
ggplot(
  data = iris, mapping = aes(x = Petal.Width, y = Sepal.Width)) +
    geom_point() + 
    labs(title = "Petal and Sepal Widths in Irises")
```

```{r gp-1-5-hint, eval=FALSE}
To create a title, use labs(title = ...).
```

```{r gp-1-5, exercise=TRUE, exercise.lines = 5}
  

```

<!-- ## `geom_point()` II -->

### Scatterplot with the `qscores` dataset

Now let's make a scatterplot using the `qscores` dataset. Load the `PPBDS.data` package and look at the `qscores` dataset by simply typing the name of the dataset.

```{r exercise-6, exercise = TRUE, exercise.lines = 5}

```

```{r exercise-6-hint, eval=FALSE}
library(...)

...
```

###

Nice! Load the `ggplot2` package. Use the `ggplot()` function to create a scatterplot using the `qscores` dataset, `rating` on the x-axis and `hours` on the y-axis. Is there a relationship between the rating of a Harvard course versus the average hours per week of workload?

```{r exercise-7, exercise = TRUE, exercise.lines = 5}

```

```{r exercise-7-hint, eval=FALSE}
library(...)

ggplot(data = qscores, mapping = aes(x = ..., y = ...)) +
  ...
```

###

Awesome! Now we want to add a `size` `aes`thetic based on the number of students enrolled in each course. Add `size = enrollment` to the other `aes`thetics of the points. Do larger classes have a higher average overall course rating? What about higher workload?

```{r exercise-8, exercise = TRUE, exercise.lines = 5}
ggplot(data = qscores, mapping = aes(x = rating, y = hours)) +
  geom_point()
```

```{r exercise-8-hint, eval=FALSE}
ggplot(data = qscores, mapping = aes(x = rating, y = hours, size = ...)) +
  geom_point()
```

<!-- ## `geom_point()` III -->

###

For the dataset `sps`, make a scatterplot with `age` on the x-axis and `health_exp_3m` on the y-axis.

```{r point-I-2, exercise=TRUE, exercise.lines=5}

```


```{r point-I-2-hint, eval=FALSE}
ggplot(data = sps, mapping = aes(x = ..., y = ...)) +
  geom_point()
```

###

Nice job! As you can see, our plot has many overlapping points making it hard to tell what's going on. Let's change the opacity by setting the `alpha` argument to 0.1.

```{r point-I-3, exercise=TRUE, exercise.lines=8, eval=FALSE}
ggplot(data = sps, mapping = aes(x = age, y = health_exp_3m)) +
  geom_point()
```

```{r point-I-3-hint, eval=FALSE}
Set the alpha argument inside of geom_point()
```

###

Great! Now try mapping the `sex` variable to the `color` aesthetic.

```{r point-I-4, exercise=TRUE, exercise.lines=10, eval=FALSE}
ggplot(data = sps, mapping = aes(x = age, y = health_exp_3m)) +
  geom_point()
```

```{r point-I-4-hint, eval=FALSE}
ggplot(aes(x = age, y = health_exp_3m, color = ...))

```

<!-- ## `geom_point()` IV -->

### Overplotting

While this plot created using the `mpg` dataset only displays 126 points, it visualizes a data set that contains 234 points.

```{r echo = FALSE, out.width = "80%"}
ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) +
  geom_point()
```

The missing points are hidden behind other points, a phenomenon known as _overplotting_. Overplotting is a problem because it provides an incomplete picture of the dataset. You cannot determine where the *mass* of the points fall, which makes it difficult to spot relationships in the data. 

### Causes of overplotting

Overplotting usually occurs for two different reasons:

1. The data points have been rounded to a "grid" of common values, as in the plot above
2. The dataset is so large that it cannot be plotted without points overlapping each other

How you deal with overplotting will depend on the cause. 

### Changing the transparency

If your overplotting is due to rounding, you can obtain a better picture of the data by making each point semi-transparent. For example you could _set_ the alpha aesthetic of the plot below to a _value_ less than one, which will make the points transparent. 

Try this now. Set the points to an alpha of 0.2, which will make each point 20% opague (i.e. five points staked on top of each other will create a solid black).

Change the transparency of the points by setting `alpha = 0.2` within `geom_point()`.

```{r exercise-9, exercise = TRUE, exercise.lines = 5}
ggplot(data = qscores, mapping = aes(x = rating, y = hours, size = enrollment)) +
  geom_point()
```

```{r exercise-9-hint, eval=FALSE}
ggplot(data = qscores, mapping = aes(x = rating, y = hours, size = enrollment)) +
  geom_point(alpha = ...)
```

## `geom_jitter()` 
<!-- I -->

A second strategy for dealing with overplotting due to rounding is to adjust the position of each point. `geom_jitter()` plots a scatterplot and then adds a small amount of random noise to each point in the plot. It is a shortcut for adding a "jitter" position adjustment to a points plot (i.e, `geom_point(position = "jitter")`). Since the noise is random, it is unlikely that two points rounded to the same location will also be jittered to the same location. The result is a jittered plot that displays more of the data and provides a simple way to inspect patterns that occur in heavily gridded or overlapping data. 

Replace `geom_point()` with `geom_jitter()` to create a jittered scatterplot.

```{r exercise-10, exercise = TRUE, exercise.lines = 5}
ggplot(data = qscores, mapping = aes(x = rating, y = hours)) +
  geom_point()
```

### Strategies for large data

Alpha and jittering are less useful for large data. Jittering will not separate the points, and a mass of transparent points can still look black.

A better way to deal with overplotting due to large data is to visualize a summary of the data, by using a histogram or a linegraph, for example.

<!-- ## `geom_jitter()` II -->

###

Do you notice anything wrong with this graph? It appears to look fine, right? Try replacing `geom_point()` with `geom_jitter()`.

```{r jit-I-1, exercise=TRUE, exercise.lines=6}
ggplot(data = trains, mapping = aes(x = att_start, y = att_end)) +
  geom_point()

```

###

As you can see, this changes things. The data on our graph was affected by overplotting, which is where points are plotted on top of each other. Jittering the points shifted them slightly from under each other. We can adjust the amount the points are jittered by setting the width. Set the `width` to `.2` within `geom_jitter()`.

```{r jit-I-3, exercise=TRUE, exercise.lines=6}
ggplot(data = trains, mapping = aes(x = att_start, y = att_end)) +
  geom_jitter()

```
###

Now set the `color` aesthetic to the `party` variable. 

```{r jit-I-4, exercise=TRUE, exercise.lines=6}
ggplot(data = trains, mapping = aes(x = att_start, y = att_end)) +
  geom_jitter()

```


```{r jit-I-4-hint, eval=FALSE}
Because color is an aesthetic, set it inside of aes().
```

<!-- ## `geom_jitter()` III -->

Hit 'Run Code' to look at the following graph:

```{r gj-1-1, exercise=TRUE, exercise.lines = 5}
ggplot(data = diamonds, mapping = aes(x = carat, y = price)) +
  geom_jitter()
```

###

`geom_jitter()` is really useful in graphs with a lot of overplotting like the one we just made, because it moves points that occupy the same location on the graph around so they're more visible. That being said, our graph still has a lot of overplotting.

Let's try to fix this by setting `width` to 0.25, to widen our jitter effect.

```{r gj-1-2, exercise=TRUE, exercise.lines = 5}
ggplot(data = diamonds, mapping = aes(x = carat, y = price)) +
  geom_jitter()
```

###

Very nice, this gives us a bit of a better sense of the total distribution. But, there's still a lot of overplotting. Let's set the `alpha` value of our points to 0.2, so we can get a bit of a better grasp on our graph.

```{r gj-1-3, exercise=TRUE, exercise.lines = 5}
ggplot(data = diamonds, mapping = aes(x = carat, y = price)) +
  geom_jitter()
```

###

Nice. Now, use what you've learned to recreate the plot below. The `alpha` of the plot is 0.2, and the `width` of the jitter distribution is 5.

```{r}
ggplot(data = diamonds, mapping = aes(x = depth, y = price)) +
  geom_jitter(width = 5, alpha = 0.2) +
  labs(title = "Depth and Price in Diamonds",
       x = "Depth",
       y = "Price")
```

```{r gj-1-5, exercise=TRUE, exercise.lines = 5}

```

## `geom_line()` 
<!-- I -->

```{r, include = FALSE}
cces_data <- cces %>%
  filter(approval_ch %in% c("Approve / Somewhat Approve", "Disapprove / Somewhat Disapprove")) %>%
  group_by(year, approval_ch) %>%
  summarize(avg_age = mean(age))
```

The `cces` dataset in the `PPBDS.data` package has been changed to show the average age of voters per year based on their approval of the president that year. The `cces` dataset was manipulated using the `filter()`, `group_by`, and `summarize()` functions within the `tidyverse` package, which you will learn how to use in the next chapter.

```{r, echo = TRUE}
cces_data
```

Use the `ggplot()` function to create a linegraph with the dataset called `cces_data` with `year` on the x-axis, `avg_age` on the y-axis, and `approval_ch` as the color aesthetic.

```{r exercise-11-setup, include = FALSE}
cces_data <- cces %>%
  filter(approval_ch %in% c("Approve / Somewhat Approve", "Disapprove / Somewhat Disapprove")) %>%
  group_by(year, approval_ch) %>%
  summarize(avg_age = mean(age))
```

```{r exercise-11, exercise = TRUE, exercise.lines = 5}

```

```{r exercise-11-hint, eval=FALSE}
ggplot(data = cces_data, mapping = aes(x = ..., y = ..., color = ...)) +
  geom_line()
```

### Test your knowledge

```{r quiz-8, echo = FALSE}
quiz(
  question("True / False: Linegraphs and scatterplots both display the relationship between two numerical variables.",
           answer("True", correct = TRUE),
           answer("False"),
           allow_retry = TRUE),
  question("True / False: It is preferred to use scatterplots over linegraphs when the variable on the x-axis has an inherent ordering, like in a time series plot.",
           answer("True"),
           answer("False", correct = TRUE),
           allow_retry = TRUE)
)
```

<!-- ## `geom_line()` II -->
###

Run the following line graph, then try changing the y axis variable to `unemploy`.

```{r line-I-2, exercise=TRUE, exercise.lines=6, eval=FALSE}
ggplot(data = economics, mapping = aes(x = date, y = pop)) +
  geom_line()
```

Nice! As you can see, we have filtered the data set `population` by `country` to create the new data frame `Afghanistan_population` which only includes data on Afghanistan. Use `Afghanistan_population` to create a line graph with `year` on the x axis and `population` (a variable that happens to have the same name as the data set) on the y axis.

```{r line-I-3, exercise=TRUE, exercise.lines=10}
Afghanistan_population <- population %>%
  filter(country == "Afghanistan")

```

```{r line-I-3-hint, eval=FALSE}
Afghanistan_population <- population %>%
  filter(country == "Afghanistan")

ggplot(data = ..., mapping = aes(x = ..., y = ...)) +
  geom_line()
```

###

Now change the line color to "purple"

```{r line-I-4, exercise=TRUE, exercise.lines=10}
Afghanistan_population <- population %>%
  filter(country == "Afghanistan")


```

```{r line-I-4-hint, eval=FALSE}

Set the color argument in geom_line() to "purple"

```

###

Great! For a final challenge, add a title and labels to both axes

```{r line-I-5, exercise=TRUE, exercise.lines=10}
Afghanistan_population <- population %>%
  filter(country == "Afghanistan")


```

```{r line-I-5-hint, eval=FALSE}
Use labs()

```

## `geom_histogram()` 
<!-- I -->

### Test your knowledge

```{r quiz-9, echo = FALSE}
quiz(
  question("A histogram is:",
           answer("A plot that displays the relationship between two numerical variables"),
           answer("A plot that visualizes the distribution of a numerical variable", correct = TRUE),
           answer("A plot that visualizes the distribution of a categorical variable"),
           allow_retry = TRUE)
)
```

###

Using the `qscores` dataset and `ggplot()`, make a histogram where `rating` is on the x-axis to see the distribution of Harvard course ratings.

```{r exercise-12, exercise = TRUE, exercise.lines = 5}

```

```{r exercise-12-hint, eval=FALSE}
ggplot(data = ..., mapping = aes(x = ...)) + ...
```

```{r quiz-10, echo = FALSE}
quiz(
  question_text("What is the default value of `bins` for this histogram? (Hint: all geoms have the same default values)",
                answer("30", correct = TRUE),
                allow_retry = TRUE)
)
```

###

Add white vertical borders demarcating the bins by adding `color = "powderblue"` and `fill = "red4"` arguments to `geom_histogram()`.

```{r exercise-13, exercise = TRUE, exercise.lines = 5}

```

```{r exercise-13-hint, eval=FALSE}
ggplot(data = qscores, mapping = aes(x = rating)) +
  geom_histogram(color = ..., fill = ...)
```

###

Specify the number of bins to be 10 via the `bins` argument and the `color` as "white" in `geom_histogram()`.

```{r exercise-14, exercise = TRUE, exercise.lines = 5}

```

```{r exercise-14-hint, eval=FALSE}
ggplot(data = qscores, mapping = aes(x = rating)) +
  geom_histogram(bins = ..., color = ...)
```

###

Specify the width of the bins to be 1 via the `binwidth` argument and the `color` as "white" in `geom_histogram()`.

```{r exercise-15, exercise = TRUE, exercise.lines = 5}

```

```{r exercise-15-hint, eval=FALSE}
ggplot(data = qscores, mapping = aes(x = rating)) +
  geom_histogram(binwidth = ..., color = ...)
```

<!-- ## `geom_histogram()` II -->
###

Let's make a histogram using geom_histogram() and the `mpg` tibble, which contains data on the fuel efficiency of different types of cars. Press 'Run Code' to continue.

```{r gh-1-1, exercise=TRUE, exercise.lines = 5}
ggplot(data = mpg, mapping = aes(x = hwy)) +
  geom_histogram()
```

###

Great. Note that if you don't specify the number of 'bins' you want for your histogram, R will generate a red message, even though there isn't an error.

###

Now, try making a histogram with x = `cty`.

```{r gh-1-2-hint, eval=FALSE}
ggplot(data = mpg, mapping = aes(x = ...)) +
  geom_histogram()
```

```{r gh-1-2, exercise=TRUE, exercise.lines = 5}

```

###

Nice! Now, let's get rid of that pesky red message by setting `bins` to 40.

```{r gh-1-3-hint, eval=FALSE}
ggplot(data = mpg, mapping = aes(x = ...)) +
  geom_histogram(bins = ...)
```

```{r gh-1-3, exercise=TRUE, exercise.lines = 5}

```

###

Very nice. Now, use what you've learned to recreate this graph.

```{r}
ggplot(data = mpg, mapping = aes(x = displ)) +
  geom_histogram(bins = 10) +
  labs(title = "Engine Size in Cars",
       x = "Engine Size (Liters)",
       y = "Number of Car Models")
```


```{r gh-1-5-hint, eval=FALSE}
Engine size is recorded with the `displ` variable, and there are 10 bins in the plot.
Use labs(title = ..., x = ..., y = ...) to add the labels.
```

```{r gh-1-5, exercise=TRUE, exercise.lines = 7}

```

## `geom_boxplot()` 
<!-- I -->

```{r quiz-11, echo = FALSE}
quiz(
  question("Which of the following are included in the five-number summary of a numerical variable used to construct a boxplot?",
           answer("Minimum", correct = TRUE),
           answer("First quartile", correct = TRUE),
           answer("Median", correct = TRUE),
           answer("Mean"),
           answer("Third quartile", correct = TRUE),
           answer("Maximum", correct = TRUE)
  )
)
```

###

Let's keep playing with the `qscores` dataset in the `PPBDS.data` package. We have filtered the dataset using the `tidyverse` package based on the five departments with the classes with the most enrollment: ECON, COMPSCI, STAT, GOV, and MATH. The filtered dataset is called `top_five_qscores`.

```{r, include = FALSE}
top_five_enrolled <- qscores %>%
  group_by(department) %>%
  summarize(enrollment = sum(enrollment)) %>%
  arrange(desc(enrollment)) %>%
  pull(department)

top_five_qscores <- qscores %>% filter(department %in% top_five_enrolled[0:5])
```

```{r, echo = TRUE}
top_five_qscores
```

### 

Using the `top_five_qscores` dataset and `ggplot()`, make a boxplot where `department` is on the x-axis and `rating` is on the y-axis.

```{r exercise-16-setup, include = FALSE}
top_five_enrolled <- qscores %>%
  group_by(department) %>%
  summarize(enrollment = sum(enrollment)) %>%
  arrange(desc(enrollment)) %>%
  pull(department)

top_five_qscores <- qscores %>% filter(department %in% top_five_enrolled[0:5])
```


```{r exercise-16, exercise = TRUE, exercise.lines = 5}

```

```{r exercise-16-hint, eval=FALSE}
ggplot(data = ..., mapping = aes(x = ..., y = ...)) +
  ...
```

```{r quiz-12, echo = FALSE}
quiz(
  question("Which department has the highest median course rating?",
           answer("COMPSCI"),
           answer("ECON"),
           answer("GOV"),
           answer("MATH", correct = TRUE),
           answer("STAT")
  ),
  question("Which department has outliers?",
           answer("COMPSCI"),
           answer("ECON"),
           answer("GOV"),
           answer("MATH", correct = TRUE),
           answer("STAT")
  ),
  question("Which department has the largest range of course ratings?",
           answer("COMPSCI"),
           answer("ECON"),
           answer("GOV", correct = TRUE),
           answer("MATH"),
           answer("STAT")
  )
)
```

<!-- ## `geom_boxplot()` II -->
###

Using the `trains` dataset, create a boxplot with `party` on the x-axis and `att_start` on the y-axis.

```{r box-I-2, exercise=TRUE, exercise.lines = 10, eval=FALSE}

```

###

Using the dataset `governors`, create a boxplot where `party` is on the x-axis and `win_margin` is on the y-axis.

```{r box-I-3, exercise=TRUE, eval=FALSE, exercise.lines=10}

```

###

Let's add some color! Change your previous boxplot so that it is outlined in blue
```{r box-I-4, exercise=TRUE, eval=FALSE, exercise.lines=10}

```

```{r box-I-4-hint,eval=FALSE}
Use the color argument and remember to put "blue" in quotes.
```

<!-- ## `geom_boxplot()` III -->
###

Let's make a boxplot using the `mpg` tibble, which shows the fuel efficiency for different types of cars. Set x = `class`, and y = `hwy`.

```{r gb-1-2-hint, eval=FALSE}
ggplot(data = mpg, mapping = aes(x = ... , y = ... )) +
  geom_boxplot()
```

```{r gb-1-2, exercise=TRUE, exercise.lines = 5}

```

###

Great! Now let's make the outliers a little bit easier to see. Set `outlier.size` to 4, and `outlier.fill` to "red".

```{r gb-1-3-hint, eval=FALSE}
Put `outlier.size` and `outlier.fill` inside of geom_boxplot().
```

```{r gb-1-3, exercise=TRUE, exercise.lines = 5}

```

###

Nice! Now let's add some labels using the `labs()` function. Title the plot "Highway Fuel Efficiency in Different Types of Cars", make x = "Type of Car", and make y = "Miles Per Gallon (Highway)".

```{r gb-1-4-hint, eval=FALSE}
labs(title = ...,
     x = ...,
     y = ...)
```

```{r gb-1-4, exercise=TRUE, exercise.lines = 5}

```

###

Awesome! Now, use what you've learned to recreate this plot.

```{r}
ggplot(data = mpg, mapping = aes(x = manufacturer, y = cty)) +
  geom_boxplot(outlier.color = "blue") +
  labs(title = "City Fuel Effiecnecy by Car Manufacturer",
       x = "Manufacturer",
       y = "Miles Per Gallon (City)")
```

```{r gb-1-5, exercise=TRUE, exercise.lines = 5}

```

## `geom_violin()` 
<!-- I -->

Let's use `geom_violin()` to make a plot with the `diamonds` tibble, which contains information about cut diamonds. Hit 'Run Code' to continue.

```{r gv-1-1, exercise=TRUE, exercise.lines = 5}
ggplot(data = diamonds, mapping = aes(x = cut, y = price)) +
  geom_violin()
```

###

Nice. Now, let's try changing the `color`, or outline, of our plot to "red" and the `fill` of the plots to "red3" within `geom_violin()`.

```{r gv-1-2, exercise=TRUE, exercise.lines = 5}

```

###

Cool. Now, let's use `draw_quantiles` to draw percentile lines on our violins, at 0.25, 0.5, and 0.75. `draw_quantiles` is an argument that goes within the `geom_violin()` function.

```{r gv-1-4-hint, eval=FALSE}
draw_quantiles = c(..., ..., ...)
```

```{r gv-1-4, exercise=TRUE, exercise.lines = 5}

```

###

Great! Now try doubling the bandwith using the `adjust` argument in `geom_violin()`.

```{r viol-I-3, exercise=TRUE, exercise.lines=8}

```

```{r viol-I-3-hint, eval=FALSE}
adjust = 2
```

###

Nice! Now try setting the `kernel` argument in `geom_violin()` to "epanechnikov".

```{r viol-I-4, exercise=TRUE, exercise.lines=8}

```

###

Well done. Now, use what you've learned about `geom_violin()` to recreate this plot:

```{r}
ggplot(data = diamonds, mapping = aes(x = cut, y = carat), color = "blue") +
  geom_violin() +
  labs(title = "Size and Quality in Diamonds",
       x = "Quality",
       y = "Size (Carats)")
```

```{r gv-1-5, exercise=TRUE, exercise.lines = 5}

```

```{r gv-1-5-hint, eval=FALSE}
aes(x = cut, y = carat)

labs(title = ..., x = ..., y = ...)
```

## `geom_bar()`

```{r quiz-13, echo = FALSE}
quiz(
  question("A barplot is:",
           answer("A plot that displays the relationship between two numerical variables"),
           answer("A plot that visualizes the distribution of a numerical variable"),
           answer("A plot that visualizes the distribution of a categorical variable",
                  correct = TRUE),
           allow_retry = TRUE)
)
```

###

We can now use a barplot to plot how many students are enrolled in classes per department. We will use the `top_five_qscores` dataset again to look at the five largest departments.

```{r barplot, include = FALSE}
top_five_enrolled <- qscores %>%
  group_by(department) %>%
  summarize(enrollment = sum(enrollment)) %>%
  arrange(desc(enrollment)) %>%
  pull(department)

top_five_qscores <- qscores %>% filter(department %in% top_five_enrolled[0:5])
```

```{r barplot-top-five-qscores, echo = TRUE}
top_five_qscores
```

Use `ggplot()` and `geom_bar()` to plot `department` on the x-axis to see the number of classes in each department.

```{r exercise-17-setup, include = FALSE}
top_five_enrolled <- qscores %>%
  group_by(department) %>%
  summarize(enrollment = sum(enrollment)) %>%
  arrange(desc(enrollment)) %>%
  pull(department)

top_five_qscores <- qscores %>% filter(department %in% top_five_enrolled[0:5])
```

```{r exercise-17, exercise = TRUE, exercise.lines = 5}

```

```{r exercise-17-hint, eval=FALSE}
ggplot(data = ..., mapping = aes(x = ...)) +
  ...
```

###

Let's go back to the `trains` dataset in the `PPBDS.data` package. Use `ggplot()` and `geom_bar()` to plot `treatment` on the x-axis.

```{r exercise-19, exercise = TRUE, exercise.lines = 5}

```

```{r exercise-19-hint, eval=FALSE}
ggplot(data = ..., mapping = aes(x = ...)) + ...
```

###

We can now map the additional variable `party` by adding a `fill = party` inside the `aes()` aesthetic mapping.

<!-- ggplot(data = trains, mapping = aes(x = treatment)) + geom_bar() -->

```{r exercise-20, exercise = TRUE, exercise.lines = 5}

```

```{r exercise-20-hint, eval=FALSE}
ggplot(data = trains, mapping = aes(x = treatment, fill = ...)) + geom_bar()
```

###

Change `fill = party` to `color = party`. What happens?

<!-- ggplot(data = trains, mapping = aes(x = treatment, fill = party)) + geom_bar() -->
```{r exercise-21, exercise = TRUE, exercise.lines = 5}

```

###

Create a side-by-side barplot by adding `position = "dodge"` to `geom_bar()`.

<!-- ggplot(data = trains, mapping = aes(x = treatment, fill = party)) + -->
<!--   geom_bar() -->
```{r exercise-22, exercise = TRUE, exercise.lines = 5}

```

```{r exercise-22-hint, eval=FALSE}
ggplot(data = trains, mapping = aes(x = treatment, fill = party)) +
  geom_bar(position = ...)
```

###

Instead of mapping `party` to `fill`, we can include it as the variable to create small multiples of the plot across the levels of `party` using `facet_wrap(~ party)`. Add this layer to the provided plot in order to create a faceted barplot.

<!-- ggplot(data = trains, mapping = aes(x = treatment)) + -->
<!--   geom_bar() -->

```{r exercise-23, exercise = TRUE, exercise.lines = 5}

```

```{r exercise-23-hint, eval=FALSE}
ggplot(data = trains, mapping = aes(x = treatment)) + geom_bar() + ...
```

###

Wonderful! Now, use what you've learned to recreate the plot below.

```{r gbr-1-5, exercise=TRUE, exercise.lines = 5}

```

```{r gbr-1-5-hint, eval=FALSE}
aes(x = party, fill = liberal)
labs(title = ..., x = ..., y = ...)
```

```{r}
ggplot(data = trains, mapping = aes(x = party, fill = liberal)) +
  geom_bar() +
  labs(title = "Political Distribution on Boston Train Platform",
       x = "Political Party", y = "Number of People")
```

###

Let's now look at the data set `diamonds`, one you should already be familiar with. Press "Run Code".

```{r bar-I-1, exercise=TRUE, exercise.lines=7}
ggplot(data = diamonds, aes(x = color)) +
  geom_bar()
```

###

Now change the x-axis variable to `cut` and run code the code chunk.

```{r bar-I-2, exercise=TRUE, exercise.lines=7}


```

```{r bar-I-2-hint, eval=FALSE}
ggplot(data = diamonds, mapping = aes(x = ...)) +
  geom_bar()
```

###

Nice! Now try mapping the `fill` aesthetic to the `clarity` variable to create a stacked barplot.

```{r bar-I-3, exercise=TRUE, exercise.lines=7}


```

```{r bar-I-3-hint, eval=FALSE}
Because we are mapping fill to a variable, it is an aesthetic. This means that is has to be mapped inside of aes().
```

###

Great! Now try creating a dodged barplot by setting the `positon` argument to "dodge".

```{r bar-I-4, exercise=TRUE, exercise.lines=7}


```

```{r bar-I-4-hint, eval=FALSE}
Set position inside geom_bar() and remember to put "dodge" in quotes.
```

###

```{r}
ggplot(data = cces, mapping = aes(x = ideology, fill = gender)) +
  geom_bar(position = "dodge")
```

For your final challenge, recreate the above dodged bar graph. 
```{r bar-I-5, exercise=TRUE, exercise.lines=7}


```

## `geom_col()`

`geom_col()` makes barplots just like `geom_bar()`. The key difference between the two is the type of data they use. Here, We use `geom_col()` because the totals for a variable are pre-counted and listed in the data set. Also note that, unlike for `geom_bar()`, we have to include both x and y in the aesthetic. We'll practice using `geom_col()` in this section.

Let's return to the first barplot we made in `geom_bar()` using the five largest departments in the `qscores` dataset. We will now count the number of classes per department in order to use the `geom_col()` layer instead. We do this using the `group_by()` and `count()` functions in the `tidyverse` package. Our new data frame is stored as `top_five_qscores_counted`.

```{r classes-counted, include = FALSE}
top_five_qscores_counted <- top_five_qscores %>%
  group_by(department) %>% count() %>% rename(count = n)
```

```{r avg-workload, echo = TRUE}
top_five_qscores_counted
```

Use `ggplot()` and `geom_col()` to plot `department` on the x-axis and `count` on the y-axis to see the number of classes in each department.

```{r exercise-18-setup, include = FALSE}
top_five_enrolled <- qscores %>%
  group_by(department) %>%
  summarize(enrollment = sum(enrollment)) %>%
  arrange(desc(enrollment)) %>%
  pull(department)

top_five_qscores <- qscores %>% filter(department %in% top_five_enrolled[0:5])

top_five_qscores_counted <- top_five_qscores %>%
  group_by(department) %>% count() %>% rename(count = n)
```


```{r exercise-18, exercise = TRUE, exercise.lines = 5}

```

```{r exercise-18-hint, eval=FALSE}
ggplot(data = top_five_qscores_counted, mapping = aes(x = ..., y = ...)) +
  ...
```

```{r quiz-14, echo = FALSE}
quiz(
  question("What's the difference between `geom_bar()` and `geom_col()`?",
           answer("`geom_bar()` is used to represent pre-counted data while `geom_col() is not."),
           answer("`geom_col()` is used to represent pre-counted data while `geom_bar() is not.",
                  correct = TRUE),
           answer("There is no difference between the two layers.")
  )
)
```

###

Let's keep working with the `qscores` dataset. Press "Run Code" to check out the graph:

```{r col-I-1, exercise=TRUE, exercise.lines=7}
aframer_qscores <- qscores %>%
  filter(department == "AFRAMER")

ggplot(data = aframer_qscores, mapping = aes(x = number, y = enrollment)) +
  geom_col()
```

###

Let's make this graph a little more interesting. Map the `color` aesthetic to the `term` variable.

```{r col-I-2, exercise=TRUE, exercise.lines=7}
aframer_qscores <- qscores %>%
  filter(department == "AFRAMER")



```

```{r col-I-2-hint, eval=FALSE}
ggplot(data = aframer_qscores, mapping = aes(x = number, y = enrollment, color = ...)) +
  geom_col()

```

###

This final question is for all you Star Wars fans out there. These are the droids you're looking for. Recreate the plot below using the dataset `droid`, which was created from filtering the `starwars` dataset to only characters who are droids.

```{r}
droid <- starwars %>%
  filter(species == "Droid")

ggplot(data = droid, mapping = aes(x = name, y = height)) +
  geom_col()
```

```{r col-I-5, exercise=TRUE, exercise.lines=7, eval=FALSE}
droid <- starwars %>%
  filter(species == "Droid")


```

## `geom_smooth()` 

Let's start by creating a scatterplot from `nhanes`, which includes data from a national health and nutrition survey. Press "Run Code":

```{r smooth-I-1, exercise=TRUE, exercise.lines=7}
ggplot(data = nhanes, mapping = aes(x = weight, y = height)) +
  geom_point()

```

###

Now try adding `geom_smooth()` to the graph.

```{r smooth-I-2, exercise=TRUE, exercise.lines=7, eval=FALSE}
ggplot(data = nhanes, mapping = aes(x = weight, y = height)) +
  geom_point()


```

Nice! As you can see, the line you just graphed represents the trend that we see in the scatter plot. See the message that R gave us? Because we didn't set the method that R uses to calculate the line, R defaulted to using "gam". Let's try setting the method to "lm" instead.

```{r smooth-I-3, exercise=TRUE, exercise.lines=7}


```

```{r smooth-I-3-hint, eval=FALSE}
Set the method inside of geom_smooth() and remember to put "lm" in quotes.
```

###

Great! Now get rid of the scatterplot by deleting `geom_point()` and only use `geom_smooth()`. Then, set the `color` aesthetic to the `gender` variable.

```{r smooth-I-4, exercise=TRUE, exercise.lines=7}


```

```{r smooth-I-4-hint, eval=FALSE}
Because color is an aesthetic, set it inside of aes().
```

###

Nice! Now add the the title "Height to Weight Relationship United States" and labels "Height in cm" to the y axis and "Weight in kg" to the x axis.

```{r smooth-I-5, exercise=TRUE, exercise.lines=7}


```

```{r smooth-I-5-hint, eval=FALSE}
Use labs() to add the title and labels.
```

###

Let's make a plot with `geom_smooth()`, and the `mpg` tibble, which records the fuel efficiency of different car models. Hit 'Run Code' to continue.

```{r gs-1-1, exercise=TRUE, exercise.lines = 5}
ggplot(data = mpg, mapping = aes(x = displ, y = cty)) +
  geom_smooth()
```

###

Nice. Now, let's make the gray confidence interval bar disappear by setting `se` to `FALSE`.

```{r gs-1-2, exercise=TRUE, exercise.lines = 5}

```

###

Looks good! Let's add some labels with labs(). We can call our plot "Engine Size and City Fuel Efficiency", our x-axis "Engine Size (Liters)", and our y-axis "City Fuel Efficiency (Miles Per Gallon)"

```{r gs-1-3, exercise=TRUE, exercise.lines = 5}

```

###

Nicely done. Now, let's try dividing up our trendline by mapping `color` to `class`, so we can get a better sense of the range of fuel efficiency in different types of cars.

```{r gs-1-4, exercise=TRUE, exercise.lines = 5}

```

###

Great! Now, use what you've learned about `geom_smooth()` to recreate the plot below.

```{r}
ggplot(data = mpg, mapping = aes(x = cty, y = hwy)) +
  geom_smooth(color = "red") +
  labs(title = "City vs. Highway Fuel Economy",
       x = "City Miles Per Gallon",
       y = "Highway Miles Per Gallon")
```

```{r gs-1-5, exercise=TRUE, exercise.lines = 5}

```

## `geom_density()`

Just like histograms, density plots give us a sense of the distribution of a data set for a given variable.  Let's start by looking at this density plot from data set `nhanes`. Press "Run Code":

```{r den1D-I-1, exercise=TRUE, exercise.lines=6}
ggplot(data = nhanes, mapping = aes(x = bmi)) +
  geom_density()
```

###

Now try switching the axes by setting `bmi` to the y axis instead.

```{r den1D-I-2, exercise=TRUE, exercise.lines=6}

```

###

Great! Now change the variable to `height` and set it to the x axis.

```{r den1D-I-3, exercise=TRUE, exercise.lines=6}

```

###

Nice! Just like in a violin plot, we can use the `adjust` argument inside of `geom_density()` to change the bandwidth of our plot. Try setting it to 1/3, which makes it a third of the size of the default.

```{r den1D-I-4, exercise=TRUE, exercise.lines=6}

```

###

Great! Now set the `fill` aesthetic to the `gender` variable.

```{r den1D-I-5, exercise=TRUE, exercise.lines=7}

```

```{r den1D-I-5-hint, eval=FALSE}
Because fill is an aesthetic, set it inside of aes().
```

###

Now we'll look at the data set `cces`. Use `cces` to make a density plot with `age` on the x axis and `ideology` set to the aesthetics `color` and `fill`.

```{r den1D-II-1, exercise=TRUE, exercise.lines=6}


```

###

Great! As you can see, we have a lot of overlapping going on. Try setting the `alpha` parameter in `geom_density()` to 0.3.

```{r den1D-II-2, exercise=TRUE, exercise.lines=6}


```

###

Nice! Now try setting the `position` parameter in `geom_density()` to "fill". Then try setting it to "stack".

```{r den1D-II-3, exercise=TRUE, exercise.lines=7}


```

###

Great! Now add a limit to the x axis with an upper bound of 90 and a lower bound of 20. After you have done this, set the `linetype` parameter in `geom_density()` to `"dotted"`.

```{r den1D-II-4, exercise=TRUE, exercise.lines=8}


```

```{r den1D-II-4-hint, eval=FALSE}
Use xlim() to add a limit on the x axis
```

###

For your final challenge of `geom_density()`, recreate the graph below made with data set `trains`.

```{r}
ggplot(data = trains, mapping = aes(x = age, fill = liberal)) +
  geom_density(alpha = 0.5) +
  labs(title = "Age Distribution in Attitudes Toward Immigration Study")
```

```{r den1D-II-5, exercise=TRUE, exercise.lines=8}


```

## `geom_bin2d()`

Welcome to `geom_bin2d()`! In this tutorial, we will be learning how to make heatmaps. `geom_bin2d()` is similar to a scatterplot or jittered scatterplot because it takes two continouous variables, but instead of plotting every individual point, it creates a heatmap of where the points are most concentrated, making it a better fit for big data.

Let's begin by looking at the data set `diamonds`. Press "Run Code":

```{r bin-I-1, exercise=TRUE, exercise.lines=6}
ggplot(data = diamonds, mapping = aes(x = cut, y = carat)) +
  geom_bin2d()
```

###

Try changing the x axis variable to `price` and the y axis variable to `clarity`
```{r bin-I-2, exercise=TRUE, exercise.lines=6, eval=FALSE}

```

###

Just like in a histogram, in a heatmap, we can set the number of bins. Set the number of bins for our plot to 20.

```{r bin-I-3, exercise=TRUE, exercise.lines=6}

```

```{r bin-I-3-hint, eval=FALSE}
Set the number of bins inside of geom_bin2d()
```

###

Also like with histograms, we can set the binwidth. Try setting binwidth to 2000.

```{r bin-I-4, exercise=TRUE, exercise.lines=6}

```

```{r bin-I-4-hint, eval=FALSE}
Set binwidth inside of geom_bin2d()
```

###

Great! Now add the title "Distribution of Diamond Cut and Price"

```{r bin-I-5, exercise=TRUE, exercise.lines=6}

```

```{r bin-I-5-hint, eval=FALSE}
Use labs()
```

## `geom_density2d()`

For our first exercise in `geom_density2d()`, we are first going to look at data from `diamonds` which you are already very familiar with. Let's start by running the code below:

```{r density-I-1, exercise=TRUE, exercise.lines=7}
ggplot(data = diamonds, aes(x = carat, y = price)) +
  geom_density2d()
```

###

Now try replacing the variable `carat` with `depth` on the x axis.

```{r density-I-2, exercise=TRUE, exercise.lines=7}


```

###

Nice! Now set the `color` aesthetic to `cut`.

```{r density-I-3, exercise=TRUE, exercise.lines=7}


```

```{r density-I-3-hint, eval=FALSE}
Because color is an aesthetic, set it inside of aes()
```

###

Great! Now use labs() to title the graph "Diamond Price, Depth and Cut"

```{r density-I-4, exercise=TRUE, exercise.lines=7}


```

###

Recreate the graph below which made using data set `qscores`:
```{r}
ggplot(data = qscores, aes(x = rating, y = hours, color = term)) +
  geom_density2d() +
  labs(title = "Harvard Class Workload and Rating")
```

```{r density-I-5, exercise=TRUE, exercise.lines=7}


```

### 

Let's make a density plot using `geom_density2d()` and the `faithful` tibble, which records information from eruptions of the Old Faithful Geyser. Hit 'Run Code'.

```{r gd2d-1-1, exercise=TRUE, exercise.lines = 5}
ggplot(data = faithful, aes(x = eruptions, y = waiting)) +
  geom_density2d()
```

###

Nice. Now, let's map `linetype` to "dotdash" within `geom_density2d()` to change the look of our plot.

```{r gd2d-1-2, exercise=TRUE, exercise.lines = 5}

```

###

Well Done. Now, let's set the `color` of our lines to "black" within `geom_density2d()`.

```{r gd2d-1-3, exercise=TRUE, exercise.lines = 5}

```

###

Well done. Now, use what you've learned about the `geom_density2d()` function to recreate the plot below.

```{r}
ggplot(data = faithful, aes(x = waiting, y = eruptions)) +
  geom_density2d(color = "red") +
  labs(title = "Eruption Length and Waiting Time for Old Faithful Eruptions",
       x = "Waiting Time (Minutes)",
       y = "Eruption Length (Minutes)")
```

```{r gd2d-1-5, exercise=TRUE, exercise.lines = 7}

```

## Advanced Plotting - `geom_point()`

For data set `Orange`, create a scatterplot with `age` on the x axis and `circumference` on the y axis.

```{r point-II-1, exercise=TRUE, exercise.lines=8}


```

```{r point-II-1-hint, eval=FALSE}
ggplot(data = Orange, aes(x = ..., y = ..., color = ...)) +
  geom_point()
```

###

Nice! Let's go back to the `qscores` data set. Use `qscores` to make a scatterplot with `hours` on the x axis and `enrollment` on the y axis. Then map the `term` variable to the `color` aesthetic and set alpha to 0.5.

```{r point-II-2, exercise=TRUE, exercise.lines=8}


```

```{r point-II-2-hint, eval=FALSE}

Set the alpha argument inside of geom_point() and the color inside of aes().

```

###

Now change the scale to square root (`sqrt`)
```{r point-II-3, exercise=TRUE, exercise.lines=8}


```

```{r point-II-3-hint, eval=FALSE}

Use the scale_y_sqrt() function.

```

###

Now let's make a scatterplot using the `diamonds` data set, with `price` on the x-axis, and `carat` on the y-axis.

```{r gp-2-1, exercise=TRUE, exercise.lines = 5}


```

###

Great! Now let's try adding some labels. Title the plot: "Carats and Price in Diamonds", and give it the caption: "The relationship between price and carats in diamonds."

```{r gp-2-2-hint, eval=FALSE}
Use the labs() function to create labels.
```


```{r gp-2-2, exercise=TRUE, exercise.lines = 5}
ggplot(data = diamonds, aes(x = price, y = carat)) + geom_point()

```

###

Perfect. Now, let's set the `alpha` of every point on the plot to 0.1, and correspond the `cut` attribute to color.

```{r gp-2-3-hint, eval=FALSE}
Color and alpha can be set within aes(), like x and y.
```


```{r gp-2-3, exercise=TRUE, exercise.lines = 5}
ggplot(data = diamonds, aes(x = price, y = carat)) + 
  geom_point() + 
  labs(title = "Carats and Price in Diamonds", caption = "The relationship between price and carats in diamonds.")
```

Wonderful. Now, let's add a smooth trend line on top of the scatterplot, and scale the x-axis to log10.

```{r gp-2-4-hint, eval=FALSE}
Use geom_smooth() to create a trendline, and scale_..._log10() to rescale the plot.
```


```{r gp-2-4, exercise=TRUE, exercise.lines = 5}
ggplot(data = diamonds, aes(x = price, y = carat)) + 
  geom_point(aes(color = cut, alpha = 0.2)) + 
  labs(title = "Carats and Price in Diamonds", caption = "The relationship between price and carats in diamonds.")
```

Nice! Now, let's move the legend position to below the plot, and set the theme of the plot to `bw`.

```{r gp-2-5-hint, eval=FALSE}
Use theme(legend.position = ) and theme_...().
```


```{r gp-2-5, exercise=TRUE, exercise.lines = 5}
  diamonds %>% ggplot(aes(x = price, y = carat), scale = log10()) +
    geom_point(aes(color = cut, alpha = 0.2)) +
    geom_smooth() +
    scale_x_log10() +
    labs(title = "Carats and Price in Diamonds", caption = "The relationship between price and carats in diamonds.")
```

## Advanced Plotting - `geom_jitter()`

Now let's use the dataset `nhanes` to make a scatterplot jittered by width .5, with `education` on the x axis, and `bmi` on the y axis.

```{r jit-II-1, exercise=TRUE, exercise.lines=6}

```

###

As you can see, there is still a lot of overplotting going on. To combat this, let's set alpha to 0.1. Let's also set the color aesthetic to `gender`

```{r jit-II-2, exercise=TRUE, exercise.lines=6}

```

```{r jit-II-2-hint, eval=FALSE}
Set alpha inside of geom_jitter() and color inside of aes()
```

###

Nice! Let's now set a limit on the y-axis with an upper bound of 60 and a lower bound of 10.

```{r jit-II-3, exercise=TRUE, exercise.lines=6}

```

```{r jit-II-3-hint, eval=FALSE}
use ylim()
```

###

Great! Let's now facet our graph by `gender` and set the number of columns to 1

```{r jit-II-4, exercise=TRUE, exercise.lines=6}

```

```{r jit-II-4-hint, eval=FALSE}
Use facet_wrap() to facet and set ncol to 1.
```

###

Nice! Now set the x-axis labels at a 45 degree angle using theme()
```{r jit-II-5, exercise=TRUE, exercise.lines=6}

```

```{r jit-II-5-hint, eval=FALSE}
Inside theme, set axis.text.x to element_text(angle = ...)

```

###

Now let's make a jittered scatterplot using `geom_jitter()` and the `diamonds` tibble. Let's put `carat` on the y-axis, and `price` on the x-axis.

```{r gj-2-1, exercise=TRUE, exercise.lines = 5}

```

###

Nice. But, our plot looks a little sloppy and it's hard to see how our data is distributed. Let's try to minimize our overplotting by setting `size` to 1, `height` to 0.25, and `alpha` to 0.2.

```{r gj-2-2, exercise=TRUE, exercise.lines = 5}

```

###

That looks a bit better! Now, try adding a red trendline using `geom_smooth()`, with `method` set to the `lm` or linear mean of the points on the plot. Let's also use the `scale_x_log10` function to make the scale of the plot logarithmic.

```{r gj-2-3, exercise=TRUE, exercise.lines = 5}

```

###

Well done. Now let's add some labels. Title our plot "Size and Price in Diamonds", our x-axis "Price (US Dollars)", and our y-axis "Size (Carats)". While we're at it, let's also map `color` to `cut`. Do you think that Ideal quality diamonds will fall above or below the trendline? What about Fair quality diamonds?

```{r gj-2-4, exercise=TRUE, exercise.lines = 5}

```

###

Good stuff. Now, use what you've learned to recreate the plot below. The color scheme is `scale_color_distiller()`, `width` = 1, and `alpha` = 0.2. `Length` is recorded as the variable `x`.

```{r}
ggplot(data = diamonds) +
  geom_jitter(aes(x = x, y = price, color = carat), width = 1, alpha = 0.2) +
  scale_color_distiller() +
  labs(title = "Length and Price in Cut Diamonds",
       x = "Length (Millimeters)",
       y = "Price (US Dollars)")
```

```{r gj-2-5, exercise=TRUE, exercise.lines = 5}

```

## Advanced Plotting - `geom_line()`

Let's revisit the dataset `economics`. Change the scale on the y-axis of the graph below to log base 10 and the color of the line to "blue".

```{r line-II-1, exercise=TRUE, exercise.lines=10}
ggplot(data = economics, aes(x = date, y = unemploy)) +
  geom_line() 
```

```{r line-II-1-hint, eval=FALSE}

Use scale_y_log10()

```

###

Nice! Now add commas to the y-axis.

```{r line-II-2, exercise=TRUE, exercise.lines=10}



```

```{r line-II-2-hint, eval=FALSE}

Use the scales library and set labels=scales::comma inside of the scale function.

```

###

Great! Now set the theme to minimalist using theme_minimal().

```{r line-II-3, exercise=TRUE, exercise.lines=10}



```

###

Nice! Now add the label "population" to the y axis and the title "Population Growth Over Time".

```{r line-II-4, exercise=TRUE, exercise.lines=10}



```

```{r line-II-4-hint, eval=FALSE}

Use labs()
```

###

Great! Now add a limit to the y axis with a lower bound of 225,000 and an upper bound of 300,000
```{r line-II-5, exercise=TRUE, exercise.lines=10}



```

```{r line-II-5-hint, eval=FALSE}

Use ylim().
```

<!-- JSE - more advanced plotting for line graphs -->
### 

Let's make a line plot using information in the `population` tibble, which annually records the populations of different nations.


```{r gl-1-1, exercise=TRUE, exercise.lines = 5}
country_pop <- population %>% 
  filter(country == "Canada") 

ggplot(data = country_pop, aes(x = year, y = population)) +
  geom_line()
```

###

Nice! Now try making a plot using x = `year`, y = `population`, but with data from "Australia".

```{r gl-1-2-hint, eval=FALSE}
population %>% filter(country == ...) %>% ggplot(aes(x = ..., y = ...)) +
  geom_line()
```

```{r gl-1-2, exercise=TRUE, exercise.lines = 5, eval=FALSE}
country_pop <- population %>%
  ...


```

###

Great, now let's try plotting the data from both countries on the same graph. Let's also set the `country` variable to `color`.

```{r gl-1-3-hint, eval=FALSE}
population %>% filter(country == ... | country == ...) %>% ggplot(aes(x = ..., y = ..., color = ...)) +
  geom_line()
```

```{r gl-1-3, exercise=TRUE, exercise.lines = 5, eval=FALSE}
country <- population %>%
  ...
```

###

Cool. Now, let's modify our graph with some different countries: "Japan", "China", and "India". While we're at it, let's use `labs()` to add some labels. Title the plot "Population Trends in Asian Countries", and label our x and y axis "Year" and "Population".

```{r gl-1-4-hint, eval=FALSE}
Use labs(title = ... +
           x = ... +
           y = ...)  to add labels.
```

```{r gl-1-4, exercise=TRUE, exercise.lines = 5}

```

###

Great. Now, use what you've learned to recreate the plot below.

```{r}
population %>% 
  filter(country == "Germany" | country == "France" | country == "Italy") %>% 
  ggplot(aes(x = year, y = population, linetype = country, color = country)) +
    geom_line() +
    labs(title = "Population in European Countries",
       x = "Year",
       y = "Population")
```


```{r gl-1-5-hint, eval=FALSE}
Use `linetype = ...`
```

```{r gl-1-5, exercise=TRUE, exercise.lines = 5}

```

###

Let's make one more `line()` graph using the `economics` tibble, with x = `date`, and y = `unemploy`.

```{r gl-2-1, exercise=TRUE, exercise.lines = 5}

```

###

Now, let's set the color of our line to "blue", and use the ylim() function so that our y-axis begins at 0, and ends at 16,000.

```{r gl-2-2, exercise=TRUE, exercise.lines = 5}

```

###

Great! Our plot looks good. That being said, it's a little bid misleading, because it doesn't account for the rise in population from 1970 to 2015.

Let's try making the y-axis show the percentage of the population that's unemployed, so the plot is a bit more useful. Keep in mind that there is no variable in `economics` that will directly tell us this figure. Note that if you're planning to copy and paste from the last question, you must remove our `ylim()` function.

```{r gl-2-3-hint, eval=FALSE}
Use the variables `unemploy` and `pop` to find the proportion of the population that is unemployed. Multiply this value by 100 to find the percentage.
```

```{r gl-2-3, exercise=TRUE, exercise.lines = 5}

```

###

Nice! Now, let's add some labels. Title the plot "Unemployment by Year", our x-axis "Year", and our y-axis "Percentage of Population Unemployed".

```{r gl-2-4, exercise=TRUE, exercise.lines = 5}

```

###

Good work. Now, use what you've learned to replicate this plot.

```{r}
economics %>% ggplot(aes(x = date)) +
  geom_line(aes(y = unemploy), color = "red") +
  geom_line(aes(y = pop), color = "blue") +
  labs(title = "Unemployment and Poulation Over Time",
       x = "Year",
       y = "Number of People")
```


```{r gl-2-5-hint, eval=FALSE}
You can use multiple `geom_line()` functions in the same `ggplot()` function.
```

```{r gl-2-5, exercise=TRUE, exercise.lines = 5}

```


## Advanced Plotting - `geom_histogram()` 

Let's keep working with our `qscores` histogram plot, which you can see below. See the message R gave us about bin widths? Change the bin width by setting the number of bins to 20.
```{r}
ggplot(data = qscores, aes(x = rating)) +
  geom_histogram(fill = "red4", color = "white") +
  labs(title = "Course Rating Distribution", y = "Count", x = "Rating")
```

```{r hist-II-1, exercise=TRUE, exercise.lines=7}
ggplot(data = qscores, aes(x = rating)) +
  geom_histogram(fill = "red4", color = "white") +
  labs(title = "Course Rating Distribution", y = "Count", x = "Rating")

```

```{r hist-II-1-hint, eval=FALSE}
Set the argument bins in geom_histogram() to 20.

```

###

Nice! Besides changing the number of bins, recall that we can change the bin width by setting it to a specific value. Change the plot so that the bins are .25 wide. (To do this you must delete the bins argument you set in the previous question)

```{r hist-II-2, exercise=TRUE, exercise.lines=7}


```

```{r hist-II-2-hint, eval=FALSE}
Set the argument binwidth in geom_histogram() to .25

```

###

Now facet the plot by `term` and set the number of columns to 2.

```{r hist-II-3, exercise=TRUE, exercise.lines=7}


```

```{r hist-II-3-hint, eval=FALSE}
Use facet_wrap() and set ncol to 2.
```

###

Great! Now change the theme to black and white using the `themes_bw()` function
```{r hist-II-4, exercise=TRUE, exercise.lines=7}


```

###

```{r}
ggplot(data = nhanes, aes(x = height)) +
    geom_histogram(color = "white", fill = "black", bins = 30) +
    facet_wrap(~ gender, ncol = 1)

```

Recreate the above histogram. It was made with data set `nhanes` with `height` on the x axis and facetted by `sex`.

```{r hist-II-5, exercise=TRUE, exercise.lines=7}


```

###

Let's use `mpg`, a tibble which contains data on the fuel efficiency of different types of cars, to make a `geom_histogram()` with x = `cty`.

```{r gh-2-1, exercise=TRUE, exercise.lines = 5}

```

###

Nice. Now, let's set `binwidth` to 1, and map `fill` to the variable `class`.


```{r gh-2-2, exercise=TRUE, exercise.lines = 5}

```

###

Great work, now, let's try changing the color scheme of our plot to the `brewer` theme, using `scale_fill_brewer()`. Remember that setting `color` in a histogram will only change the outline of the bins, and you need to change `fill` to change the interior color of the bins. That being said, let's also set `color` to "black" to create a black outline around our bins.

```{r gh-2-3, exercise=TRUE, exercise.lines = 5}

```

###

Nice. Now, let's set `position` to "fill", to get a better sense of the types of cars at each fuel economy value, not just the quantity. While we're at it, let's add some labels with labs(). Title our plot "Fuel Economy by Class of Car", our x-axis  "City Fuel Efficiency (Miles Per Gallon)", and our y-axis "Distribution of Car Models"

```{r gh-2-4, exercise=TRUE, exercise.lines = 5}

```

###

Well done. Finally, use what you've learned about `geom_histogram()` to replicate the plot below.

```{r}
mpg %>% ggplot(aes(x = hwy, color = class)) +
  geom_histogram(fill = "white", bins = 5, position = "dodge") +
  labs(title = "Highway Fuel Economy by Car Type",
       x = "Miles Per Gallon (Highway)",
       y = "Number of Car Models")
```

```{r gh-2-5, exercise=TRUE, exercise.lines = 5}

```

## Advanced Plotting - `geom_boxplot()`

For dataset `diamonds`, create a boxplot with `clarity` on the x axis and `price` on the y axis

###

```{r box-II-1, exercise=TRUE, exercise.lines=10}

```

```{r box-II-1-hint, eval=FALSE}
Review geom_boxplot I
```
###

Try changing the scale of the y axis to log base 10

```{r box-II-2, exercise=TRUE, exercise.lines=10}

```

```{r box-II-2-hint,eval=FALSE}
Use the scale_y_log10() function
```

###

Nice job! For now, I have set the scale on the y axis back to continuous. In our first diamonds boxplot, R automatically set labels on the tick marks at 0, 5000, 10000 and 15000. Try changing this so that we have labels at 0, 90000 and 18000. After this, add dollar signs to your labels. Note, this is different from and does not use labs()!

```{r box-II-3, exercise=TRUE, exercise.lines=10}
diamonds %>%
  ggplot(aes(x = clarity, y = price))+
    geom_boxplot()+
    scale_y_continuous()
```

```{r box-II-3-hint,eval=FALSE}
Add breaks in the scale function to change label location. Also in the scale function, use the scales library to add dollars signs
```

###
Now facet the plot by `cut` and set the number of columns to 2

```{r box-II-4, exercise=TRUE, exercise.lines=10}
diamonds %>%
  ggplot(aes(x = clarity, y = price)) +
    geom_boxplot() +
    scale_y_continuous(breaks = c(0,9000,18000),labels = scales::dollar)
```

```{r box-II-4-hint,eval=FALSE}
Use facet_wrap() and set ncol to 2
```

###

```{r}
cces %>%
  ggplot(aes(x = age, y = ideology)) +
    geom_boxplot() +
    facet_wrap(~ race, ncol = 2) +
    labs(title = "Age, Ideology and Race in American Election Data")
```


Recreate the above boxplot from data set `cces`. Note that the plot is facetted by `race` with the number of columns set to 2.

```{r box-II-5, exercise=TRUE, exercise.lines=10}

```

```{r box-II-5-hint, eval=FALSE}
Use facet_wrap() to facet and labs() to create labels
```

###

Make a boxplot using the `diamonds` tibble with x = `cut`, and y = `price`.

```{r gb-2-1, exercise=TRUE, exercise.lines = 5}

```

###

Great! Now, use `coord_flip()` to convert the plot into a horizontal boxplot, and get rid of the outliers by setting `outlier.alpha` to 0. Note that you can also make outliers dissapear by setting `outlier.color` to "white".

```{r gb-2-2, exercise=TRUE, exercise.lines = 5}

```

###

Wonderful. Now, let's use `labs()` to add some labels to our plot. Title the plot "Diamond Price by Quality", call the x-axis "Price (US Dollars)", and call the y-axis "Quality".

```{r gb-2-3, exercise=TRUE, exercise.lines = 5}

```

###

Great! Now, let's zoom in on our plot by setting  `xlim()` to the vector `c(500, 7000)`. Remember that `xlim()` should be placed inside of the `coord_` function, in this case, `coord_flip`.

```{r gb-2-4, exercise=TRUE, exercise.lines = 5}

```

###

Nice! Note that you can also zoom in on a plot by using the `xlim()` or `ylim()` functions outside of the `coord_` function without using a vector, but this is not ideal because it will disregard points outside of the zoom when calculating the average and percentile lines of a `boxplot()`. You can try this yourself by deleting the argument from the last question, and adding '+ xlim(7500)' to our plot. Notice how the averages are slightly different?

###

Now, use what you've learned to recreate the plot below.

```{r}
ggplot(data = diamonds, aes(x = price, y = carat, group = cut_interval(price, n = 4))) +
  geom_boxplot(outlier.alpha = 0.1, color = "red") +
  labs(title = "Size and Quality in Diamonds",
       x = "Price (US Dollars)",
       y = "Size (Carats)")
```

```{r gb-2-5-hint, eval=FALSE}
In order to use two continouous variables in a `boxplot()`, use the `group = cut_` function, in this case, `group = cut_interval(..., n = ...)`. Remember that this function must be inside of `aes()`.
```

```{r gb-2-5, exercise=TRUE, exercise.lines = 5}

```

## Advanced Plotting - `geom_violin()`

Let's use the `mpg` tibble, which tells us the fuel efficiency of different car models, to make a plot with `geom_violin()`. Let's map our x-axis to `class`, and our y-axis to `displ`.

```{r gv-2-1, exercise=TRUE, exercise.lines = 5}

```

###

Well done. Now, let's add some percentile lines with `draw_quantiles` at 0.33 and 0.66. Let's also set `trim` to FALSE, to add tails to the violins. Both arguments should go inside the `geom_violin()` function.

```{r gv-2-2-hint, eval=FALSE}
draw_quantiles = c(..., ..., ...)
```

```{r gv-2-2, exercise=TRUE, exercise.lines = 5}

```

###

Good. Now, let's add some labels with `labs()`. Let's title our plot "Engine Size by Car Type", our x-axis "Car Type", and our y-axis "Engine Size (Liters)". Let's also use `theme_void()` to give our plot a cleaner look.

```{r gv-2-3, exercise=TRUE, exercise.lines = 5}

```

###

Nice Work. Now, let's try using layers to give our plot a bit more information. Use `geom_jitter()` to add a new layer to our plot, and map `color` to `maufacturer`, so we can get a sense of how car brand has to do with engine size. We use `geom_jitter()` over `geom_point()` in this scenario because it will spread points that occupy the same coordinates, making it easier to visualize the distribution of data. That being said, let's set `height` to 0, so all of the data points are accurate to their actual `displ` values. We can also set `width` to 0.2, so that the points stay more or less within the violins.

```{r gv-2-4, exercise=TRUE, exercise.lines = 5}

```

###

Cool. Now use what you've learned to replicate the plot below.

```{r}
ggplot(data = mpg, aes(x = class, y = cty)) +
  geom_violin() +
  geom_jitter(aes(color = hwy, shape = drv), height = 0, width = 0.2)
```

```{r gv-2-5, exercise=TRUE, exercise.lines = 5}

```

###

Using the `diamonds` dataset, use `geom_violin()` and the `"gaussian"` `kernel` to create a plot with `cut` on the x axis and `price` on the y axis.

```{r viol-II-1, exercise=TRUE, exercise.lines=8}

```

###

Great! Now use `ylim()` set a limit on the y axis with an upper bound of 10,000 and a lower bound of 0.

```{r viol-II-2, exercise=TRUE, exercise.lines=8}

```

###

Nice! Now use `fill` to color the plot `"blue"`.

```{r viol-II-3, exercise=TRUE, exercise.lines=8}

```

###

Great! Now use the scales library to add commas to the y-axis.

```{r viol-II-4, exercise=TRUE, exercise.lines=8}

```

###

Awesome! Now change the theme to dark using `theme_dark()`.

```{r viol-II-5, exercise=TRUE, exercise.lines=8}

```

## Advanced Plotting - `geom_bar()`

Using data set `sps`, a public health experiment in Mexico, make a dodged bar plot with `education` on the x axis and `sex` mapped to the fill aesthetic.

```{r bar-II-1, exercise=TRUE, exercise.lines=7}


```

###

Great! Try changing the scale with the function `scale_y_sqrt()`
```{r bar-II-2, exercise=TRUE, exercise.lines=7}


```

###

Nice! Now move the key to the bottom using the function `theme(legend.position = "bottom")`
```{r bar-II-3, exercise=TRUE, exercise.lines=7}


```

###

Now facet the graph by `treatment` and set the number of columns to 2.

```{r bar-II-4, exercise=TRUE, exercise.lines=7}


```

```{r bar-II-4-hint, eval=FALSE}
To facet, use facet_wrap() and inside, set ncol to 2.

```
###

Nice! Now make the theme of the plot minimalist and add a title of your choice.

```{r bar-II-5, exercise=TRUE, exercise.lines=7}


```

```{r bar-II-5-hint, eval=FALSE}
To set the theme, use theme_minimal() and to add a title, use labs().

```

### 

Let's make a barplot using `trains`, a tibble that records attitudes towards immigration on a Boston train platform before and after an experiment. Map our x variable to `att_start`.

```{r gbr-2-1, exercise=TRUE, exercise.lines = 5}

```

###

Great. Now, add some labels with `labs()`, let's title our plot "Attitudes Towards Immigration on Boston Train Platform", call our x-axis "Attitude Towards Immigration (Higher Means More Conservative)", and our y-axis "Number of People". Let's also map `fill` to `party`. Notice any patterns?

```{r gbr-2-2, exercise=TRUE, exercise.lines = 5}

```

###

Nicely done. Let's change the aesthetics of our graph to make it a little more appealing. Let's change our theme using `theme_bw()`, and change our color scheme using `scale_color_brewer()`, and set our `palette` to `"Purples"`.

```{r gbr-2-3, exercise=TRUE, exercise.lines = 5}

```

###

Good work. Now, let's use `facet_wrap()` to divide our graph by the `liberal` variable.

```{r gbr-2-4-hint, eval=FALSE}
facet_wrap( ~ ...)
```

```{r gbr-2-4, exercise=TRUE, exercise.lines = 5}

```

###

Well done. Now, use what you've learned to recreate the plot below.

```{r}
ggplot(data = trains, mapping = aes(x = att_end, fill = gender)) +
  geom_bar() +
  facet_wrap( ~ treatment) +
  labs(title = "Attitudes Towards Immigration After Experimentation",
       x = "Attitude Towards Immigration (Higher Means More Conservative)",
       y = "Number of People")
```

```{r gbr-2-5, exercise=TRUE, exercise.lines = 5}

```

## Advanced Plotting - `geom_col()`

Let's begin with the data set `starwars`. Using `naboo`, make a bar plot of only characters from Naboo with `name` on the x axis and `height` on the y axis. In order to do this, we must first filter by `homeworld`, which has been done for you below.

```{r col-II-1, exercise=TRUE, exercise.lines=7, eval=FALSE}
naboo <- starwars %>%
  filter(homeworld == "Naboo")



```

###

Great! Now set the `fill` aesthetic to the variable `sex`.

```{r col-II-2, exercise=TRUE, exercise.lines=7}
naboo <- starwars %>%
  filter(homeworld == "Naboo")


```

```{r col-II-2-hint, eval=FALSE}
Because fill is an aesthetic, we set it inside aes()
```

###

Nice! As you can see, there is some overlapping text making it hard to read the x axis. Let's fix this by setting the x axis text size to 4 using `theme()`.

```{r col-II-3, exercise=TRUE, exercise.lines=7}
naboo <- starwars %>%
  filter(homeworld == "Naboo")

```

```{r col-II-3-hint, eval=FALSE}
Use theme() and set axis.text.x to element_text(size = 4)

```

###

Nice! Now try making the bars thinner by setting bar width to .5

```{r col-II-4, exercise=TRUE, exercise.lines=7}
naboo <- starwars %>%
  filter(homeworld == "Naboo")

```

```{r col-II-4-hint, eval=FALSE}
Set width inside of geom_col()
```

###

For your final challenge, recreate the plot below using the dataset `eng_qscores` which was made from the dataset `qscores` and was filtered to only include data where `department` == `ENGLISH`. Additionally, the size of the text on the x axis was set to size 5 using `theme()`.

```{r}
eng_qscores <- qscores %>%
  filter(department == "ENGLISH")

ggplot(data = eng_qscores, aes(x = number, y = hours)) +
  geom_col() +
  theme(axis.text.x = element_text(size = 5)) +
  labs(title = "Hours of Work in Harvard English Classes")
```

```{r col-II-5, exercise=TRUE, exercise.lines=10, eval=FALSE}
eng_qscores <- qscores %>%
  filter(department == "ENGLISH")

```

```{r col-II-5-hint, eval=FALSE}
Use labs() to add a title and use theme() and set axis.text.x to element_text(size = 5)
```

###

Let's make a plot recording the fuel efficiency of different Toyota models with the `toyota_mpg` tibble, and `geom_col()`. Set x = `hwy`, and y = `cty`.

```{r gc-2-1-hint, eval=FALSE}
toyota_mpg <- mpg %>% 
  filter(manufacturer == "toyota")

ggplot(data = toyota_mpg, ...)
```

```{r gc-2-1, exercise=TRUE, exercise.lines = 7}
toyota_mpg <- mpg %>% 
  filter(manufacturer == "toyota")


```

###

Nicely done. But wait a second, our numbers seem way off! Because `geom_col()` uses the `stacked` position by default, it's lumping all the different car models with the same name on the same bar. Let's set our `position` to `dodge`, and continue. Let's also set `color` to "white" to make a white outline around our bars.

```{r gc-2-2, exercise=TRUE, exercise.lines = 7}
toyota_mpg <- mpg %>% 
  filter(manufacturer == "toyota")

```

###

Wonderful. Now, let's map `fill` to the `class` variable. Let's also make some labels for our legend. Note that this must be done inside of a `scale()` function. Let's make this `scale()` function `scale_fill_discrete()` for now, so it won't change anything except for our legend.

Let's call our legend "Car Types", and our variables "Small", "Medium", "Pickup Truck", and "SUV".

```{r gc-2-3-hint, eval=FALSE}
sacle_...(name = ..., labels = c(..., ..., ...))
```

```{r gc-2-3, exercise=TRUE, exercise.lines = 7}
toyota_mpg <- mpg %>% 
  filter(manufacturer == "toyota")
```

###

Well done. Now, let's use `labs()` to make some labels for the rest of our plot. Let's call our plot "Highway and City Fuel Economy in Toyota Cars", our x-axis "Miles Per Gallon (Highway)", and our y-axis "Miles Per Gallon (City)". Let's also change the theme of our plot to 'theme_classic()'

```{r gc-2-4, exercise=TRUE, exercise.lines = 7}
toyota_mpg <- mpg %>% 
  filter(manufacturer == "toyota")
```

###

Excellent. Now, use what you've learned about `geom_col()` to replicate the plot below. The theme is `theme_bw()`.

```{r}
mpg %>% 
  filter(manufacturer == "audi") %>% 
  ggplot(aes(x = displ, y = hwy, fill = drv)) +
    geom_col() +
    theme_bw() +
    scale_fill_discrete(name = "Drive Mode", 
                        labels = c("Front Only", "Four Wheel")) +
    labs(title = "Fuel Economy and Engine Size in Toyota Cars",
         x = "Engine Size (Liters)",
         y = "Miles Per Gallon (Highway)")
```

```{r gc-2-5, exercise=TRUE, exercise.lines = 10}
audi_mpg <- mpg %>% 
  filter(manufacturer == "audi")

```

## Advanced Plotting - `geom_smooth()`

Let's start by looking at the data set `trains`, which includes data on an experiment about attitudes towards immigration. Using `geom_smooth()` and the `"gam"` method, create a graph from `trains` with `att_start` on the x axis and `att_end` on the y axis.

```{r smooth-II-1, exercise=TRUE, exercise.lines=7}


```

```{r smooth-II-1-hint, eval=FALSE}
ggplot(data = ..., mapping = aes(x = ..., y = ...)) +
  geom_smooth(method = "...")
```

###

Nice! Now set the `color` aesthetic to the `treatment` variable and set `alpha` to `.75`.

```{r smooth-II-2, exercise=TRUE, exercise.lines=7}


```

```{r smooth-II-2-hint, eval=FALSE}
Because color is an aesthetic, set it inside of aes(). Set alpha inside of geom_smooth().
```

###

Great! Now move the legend to the top of the graph using `theme()`.

```{r smooth-II-3, exercise=TRUE, exercise.lines=7}


```

```{r smooth-II-3-hint, eval=FALSE}
Set legend.position to "top".
```

###

Nice! As you can see, R has labeled the tick marks for 4, 8 and 12. Move them to 5, 10 and 15 instead on both axes.

```{r smooth-II-4, exercise=TRUE, exercise.lines=7}


```

```{r smooth-II-4-hint, eval=FALSE}
Set the tickmarks through a vector inside of scale_y_continuous() and scale_x_continous().
```

###

Now set the theme to black and white. Then add the labels "attitude start" to the x axis and "attitude end" to the y axis.

```{r smooth-II-5, exercise=TRUE, exercise.lines=7}


```

```{r smooth-II-5-hint, eval=FALSE}
For the theme, use the theme_bw() function. To add labels, use labs().
```

###

Now let's use the `iris` tibble, which records the dimensions of samples of iris flowers, and `geom_smooth()` to make a plot with `x = Petal.Length`, and `y = Petal.Width`.

```{r gs-2-1, exercise=TRUE, exercise.lines = 5}

```

###

Nice. Now, let's map `color` to `Species`. Let's also use the "Reds" color scheme from `scale_color_brewer()`.

```{r gs-2-2, exercise=TRUE, exercise.lines = 5}

```

###

Well done. Now, let's add some labels with `labs()`. Call our plot "Petal Length and Width in Iris Species", our x-axis "Petal Length", and our y-axis "Petal Height".

Let's also change the labels on our legend. Note that this must be done inside of our `scale()` function, because both the `scale()` function and the legend correspond to `color`. Let's call our legend "Iris Species", and our variables "Setosa Iris", "Blue Flag Iris", and "Virginia Iris".

```{r gj-2-3-hint, eval=FALSE}
scale_...(name = ..., labels = c(..., ..., ...))
```

```{r gs-2-3, exercise=TRUE, exercise.lines = 5}

```

###

Great. Now, let's make our trendlines represent the linear mean of their data, by setting `method` to `lm`. Let's also use `theme_bw()` theme, and move our legend to the bottom of our plot using `legend.position`. Remember that this must be done within a `theme()` function.

```{r gs-2-4, exercise=TRUE, exercise.lines = 5}

```

###

Good work. Now, use what you've learned to recreate the graph below. The scale for the legend is "discrete", and the color is "purple". Good luck.

```{r}
ggplot(data = iris, mapping = aes(x = Sepal.Width, y = Sepal.Length, linetype = Species)) +
    geom_smooth(se = FALSE, color = "purple") +
    labs(title = "Sepal Width and Length in Iris Species",
         x = "Sepal Width",
         y = "Sepal Height") +
    scale_linetype_discrete(name = "Iris Species:", 
                            labels = c("Setosa Iris:", "Blue Flag Iris:", 
                                       "Virginia Iris:")) +
    theme(legend.position = "top")
```

```{r gs-2-5, exercise=TRUE, exercise.lines = 5}

```

## Advanced Plotting - `geom_density()`

Let's make a plot using `geom_density()` and the `qscores` tibble, which records student evaluation data for Harvard classes. Map x to `rating`.

```{r gd-2-1, exercise=TRUE, exercise.lines = 5}

```

###

Well done. Now, let's map `linetype` to `term` within `aes()`. Let's also give our legend some labels using `scale_linetype_discrete()`. Let's give it the `name` "Class Semester", and the `labels` "Fall 2018" and "Spring 2019".

```{r gd-2-2, exercise=TRUE, exercise.lines = 5}

```

###

Nice. Now, let's use `labs()` to give our plot some labels. We can title our plot "Distribution of Harvard Class Student Evaluation Ratings", our x-axis "Rating", and our y-axis "Density of Classes".

Let's also add an `xlim()` function, to set the range of x values on our plot to (2.5, 5).

```{r gd-2-3, exercise=TRUE, exercise.lines = 5}

```

###

Great. Now, let's use `theme(legend.position)` to move our legend to the "bottom" of the plot. Let's also use `theme_classic` to change the look of the plot.

```{r gd-2-4, exercise=TRUE, exercise.lines = 5}

```

###

Good stuff. Now, use what you've learned about `geom_density()` to recreate the plot below.

```{r}
ggplot(data = qscores, aes(x = enrollment, color = term)) +
  geom_density() +
  scale_color_discrete(name = "Class Semester", labels = c("Fall 2018", "Spring 2019")) +
  xlim(0, 200) +
  labs(title = "Distribution of Students Enrolled in Harvard Classes",
       x = "Number of Students Enrolled",
       y = "Density of Classes")
```

```{r gd-2-5, exercise=TRUE, exercise.lines = 5}

```

###

Now let's practice using `geom_density()` and the `diamonds` tibble to make another density plot.

```{r gd-1-1, exercise=TRUE, exercise.lines = 5}
ggplot(data = diamonds, aes(x = cut)) +
  geom_density()
```

###

Nice. Let's map `color` to the variable of the same name, `color`, from the `diamonds` tibble. Note that you can also use `fill` for `geom_density()`, but in this case it's not ideal because the colored areas overlap too much.

Let's also rewrite our legend with the `scale_color_discrete()` function. Give it the `name` "Diamond Color", and the `labels` "Best", "Great", "Good", "Decent", "Okay", "Not Good", and "Worst".

```{r gd-1-2, exercise=TRUE, exercise.lines = 5}

```

###

Good stuff. Now, let's use `labs()` to give our plot some labels. Title our plot `"Diamond Color And Price"`, our x-axis `"Price (US Dollars)"`, and our y-axis `"Number of Diamonds"`.

Let's also use `theme_light()` and `scale_color_brewer()` with `pallete = "Set2"` to change the look of our plot.


```{r gd-1-3, exercise=TRUE, exercise.lines = 5}

```

###

Nice. Now let's try something different. Set `position` to "stack", so it's a little easier to see the lines over each other. This places the data from each consecutive color value over top of the data that's already been plotted, 'stacking' the data. Now, we can change our `color` mapping to `fill` (you will need to do this in the `scale()` functions as well).

Finally, let's use `theme(legend.position)` to move our legend to the "right" of our plot.

```{r gd-1-4, exercise=TRUE, exercise.lines = 5}

```

###

Excellent. Now, use what you've learned about `geom_density()` to recreate the plot below. The brewer color palette is "Greens".

```{r}
ggplot(data = diamonds, aes(x = carat, color = cut)) +
  geom_density() +
    labs(title = "Distribution of Size in Diamonds",
         x = "Size (Carats)",
         y = "Density of Diamonds") +
    scale_color_brewer(palette = "Greens", name = "Diamond Quality")
```

```{r gd-1-5, exercise=TRUE, exercise.lines = 5}

```

## Advanced Plotting - `geom_bin2d()`

Welcome to geom_bin2d()! Let's first look at the data set `cces`. Use `cces` to make a heatmap with `education` on the x axis and `ideology` on the y axis.

```{r bin-II-1, exercise=TRUE, exercise.lines=6}

```

###

Nice! As you can see, our x axis tick mark labels are overlapping each other. Let's turn them vertical by setting their angle to 90 using theme().

```{r bin-II-2, exercise=TRUE, exercise.lines=6}

```

###

Great! Now use the function `theme(legend.position = "top")`to move the legend to the top

```{r bin-II-3, exercise=TRUE, exercise.lines=6}

```

###

Nice! Now facet the heatmap by `gender` and set the number of columns to 2.
```{r bin-II-4, exercise=TRUE, exercise.lines=6}

```

```{r bin-II-4-hint, eval=FALSE}
Use facet_wrap() to facet and set ncol to 2
```

###

For your final challenge, recreate the graph below made from data set `nhanes`.

```{r}
ggplot(data = nhanes, mapping = aes(x = hh_income, y = education)) +
  geom_bin2d() +
  facet_wrap(~gender, ncol = 2) +
  theme(axis.text.x = element_text(angle = 90))
```

```{r bin-II-5, exercise=TRUE, exercise.lines=8}

```

###

Let's now make a heatmap using `geom_bin2d()` and the `qscores` tibble, which tracks Harvard student course evaluation information. Let's set x to `hours`, and y to `rating`.

```{r gb2d-2-1, exercise=TRUE, exercise.lines = 5}

```

###

Nice. Now, let's set the `binwidth` argument to 0.1, to give our plot's information a bit more detail. Let's also use `theme_dark()` to change the look of our plot.

```{r gb2d-2-2, exercise=TRUE, exercise.lines = 5}

```

###

Well done. Now, let's use the `xlim()` and `ylim()` functions to remove the outliers and focus more on the bulk of our data. Set our `xlim()` to (2, 5) and our `ylim()` to (0, 5).


```{r gb2d-2-3, exercise=TRUE, exercise.lines = 5}

```

Good Work. Now, let's add some labels to both our plot and our legend, using the `labs()` and `scale()` functions. Let's title our plot "Harvard Class Student Evaluation Ratings by Weekly Work Hours", our x-axis "Weekly Work Hours", and our y-axis "Class Rating".

In order to change the name of our legend, we need to call the `scale_fill_continous()` function, even though it doesn't actually do anything on its own. Because we're working with a continuous variable mapped to `fill`, `scale_fill_continous()` is already the default setting. Legend titles, however, must be placed inside of a `scale_()` function corresponding to what they represent, in this case, `fill`.

Anyways, let's set the `name` of our legend "Number of Classes".

```{r gb2d-2-4, exercise=TRUE, exercise.lines = 5}

```

###

Well done. Now, use what you've learned about `geom_bin2d()` to recreate this plot.

```{r}
ggplot(data = qscores, aes(x = enrollment, y = rating)) +
  geom_bin2d() +
  scale_fill_continuous(name = "Number of Classes") +
  labs(title = "Harvard Class Enrollment and Student Evaluation Ratings",
       x = "Number of Students Enrolled",
       y = "Class Rating") +
  xlim(0, 200)
```

```{r gb2d-2-5, exercise=TRUE, exercise.lines = 5}

```

## Advanced Plotting - `geom_density2d()`

Let's start by looking at data set `mpg`. Use `mpg` to make a density plot with `displ` on the x axis, `hwy` on the y axis and `class` mapped to the color aesthetic.

```{r density-II-1, exercise=TRUE, exercise.lines=7}


```

###

Nice! Now set a lower limit of 0 and an upper limit of 30 on the y axis.

```{r density-II-2, exercise=TRUE, exercise.lines=7}


```

```{r density-II-2-hint, eval=FALSE}
use ylim()
```

###

Now instead of setting `class` to color, try facetting by `class` and setting the number of columns to 3

```{r density-II-3, exercise=TRUE, exercise.lines=7}


```

```{r density-II-3-hint, eval=FALSE}
Use facet_wrap() to facet and set ncol to 3
```

###

Great! Now change the theme to light.

```{r density-II-4, exercise=TRUE, exercise.lines=7}


```

```{r density-II-4-hint, eval=FALSE}
Use theme_light()
```

###

Nice! Now recreate this density plot made using the dataset `airquality`:

```{r}
ggplot(data = airquality, aes(x = Ozone, y = Temp)) +
  geom_density2d() +
  theme_minimal() +
  facet_wrap(~ Month, ncol = 3)
```

```{r density-II-5, exercise=TRUE, exercise.lines=7}


```

### 

Our last density plots using `geom_density2d()` will graph data from the `mpg` tibble, which records the fuel efficiencies of different car models. Let's map x to `cty`, and y to `hwy`.

```{r gd2d-2-1, exercise=TRUE, exercise.lines = 5}

```

###

Nicely done. Let's say, for whatever reason, one desired to decrease the resolution of their `geom_density2d()` plot. You can do this by mapping `n` to the number of vertices you want on your polygons. Try it! Let's set `n` to `10` within `geom_density2d()`.

```{r gd2d-2-2, exercise=TRUE, exercise.lines = 5}

```

###

Great. Now, let's try mapping `color` to `class` inside `aes()`. Notice how this creates a number of smaller density plots. Let's also add some labels the legend we just generated.

Note that this must be done inside of a `scale()` function that corresponds to `color`. In this case, because we are working with a categorical variable, we will use `scale_color_discrete`. Let's call our legend's `name` "Type of Car", and our variables "Sports Car", "Compact", "Midsize", "Minivan", "Pickup Truck", and "SUV".

```{r gd2d-2-3-hint, eval=FALSE}
sacle_...(name = ..., labels = c(..., ..., ...))
```

```{r gd2d-2-3, exercise=TRUE, exercise.lines = 5}

```

###

Nice Work. Now, we can add some labels to the rest of our plot with `labs()`. Title our plot "Highway and City Fuel Efficiency in Different Car Types", our x-axis "City Miles Per Gallon", and our y-axis "Highway Miles Per Gallon".

Let's also move our legend to the "top" of the plot using `theme(legend.position)`, and change the color scheme of our plot with `scale_color_brewer()` using `palette` "Set1".

```{r gd2d-2-4, exercise=TRUE, exercise.lines = 5}

```

###

Good Stuff. Now, use what you've learned about `geom_density2d()` to replicate the plot below.

```{r gd2d-2-5, exercise=TRUE, exercise.lines = 5}
ggplot(data = mpg, aes(x = displ, y = hwy, linetype = drv)) +
  geom_density2d() +
  scale_color_discrete(name = "Type of Drive Train", labels = c("4 Wheel", "Front Only", "Rear Only")) +
  labs(title = "Engine Size and Highway Miles Per Gallon in Car Types",
       x = "Engine Size (Liters)",
       y = "Highway Miles Per Gallon")
```

## Advanced Plotting - `geom_countour_filled()`

Let's make a plot using `faithfuld`, a modified version of the `faithful` tibble, and `geom_contour_filled()`. `faithfuld` is different from `faithful` because it includes the `density` variable, which is important for plots made with `geom_contour_filled()`.

Hit 'Run Code'.

```{r gcf-1-1, exercise=TRUE, exercise.lines = 5}
ggplot(data = faithfuld, mapping = aes(x = eruptions, y = waiting, z = density)) +
  geom_contour_filled()
```

###

`geom_contour_filled()` and `geom_contour()` are unique functions, because unlike `geom_density2d()` or `geom_bin2d()`, they require a `density` variable to be mapped to their z coordinate. This makes it very hard to make a `geom_contour_filled()` plot with a data set without `density`.

Try making a plot with `geom_contour_filled()` and the `diamonds` tibble. Map x to `price`, y to `carat`, and z to `depth`.

```{r gcf-1-2, exercise=TRUE, exercise.lines = 5}

```

###

Weird, right? Even though the parameters for making a plot with `geom_contour_filled()` are very specific, many of the aesthetic settings you're familiar with still work with it. Try using `scale_fill_brewer(palette = "Purples")` to change the color scheme of the plot.

```{r gcf-1-3, exercise=TRUE, exercise.lines = 5}

```

###

Cool. We can also use `labs()` to add labels like with any other plot. Title our plot "Waiting Time and Eruption Duration from Old Faithful Geyser", our x-axis "Eruption Duration (Minutes)", and our y-axis "Waiting Time (Minutes)". We can also add to our `scale_fill_brewer()` function to set the `name` of our legend to "Density of Eruptions".

```{r gcf-1-4, exercise=TRUE, exercise.lines = 5}

```

###

Nicely done. Now, use what you've learned about `geom_contour_filled()` to recreate the plot below. The color palette is the `Spectral` palette of `scale_fill_brewer()`.

```{r gcf-1-5, exercise=TRUE, exercise.lines = 5}
faithfuld %>% ggplot(aes(x = waiting, y = eruptions, z = density)) +
  geom_contour_filled() +
  scale_fill_brewer(palette = "Spectral", name = "Density of Eruptions") +
  labs(title = "Waiting Time and Eruption Duration from Old Faithful Geyser",
       x = "Waiting Time (Minutes)",
       y = "Eruption Duration (Minutes)")
```

## The `tidyverse`

Look at all of the awesome plots you created!! Now it's time to learn more about data wrangling using the `tidyverse`. We'll go over the following functions in this tutorial:

* **filter()** a data frames existing rows by only picking a subset of them.
* **select()** specific variable columns in a data set. Additional functions like **slice()** can further subset the data.
* **arrange()** its rows. For example, sort the rows of weather in ascending or descending order of temp.
* **group_by()** its rows. In other words, assign different rows to be part of the same group. We can then combine **group_by()** with **summarize()** to report summary statistics for each group separately. 
* **mutate()** its existing columns/variables to create new ones. 

###

Before we get started, load the `tidyverse` collection of packages and the package `PPBDS.data`.

```{r data-I-1, exercise=TRUE, exercise.lines=3}

```

###

Let's take a `glimpse()` at the data set `cces`. Press "Run Code".

```{r data-I-2, exercise=TRUE, exercise.lines=3}
glimpse(cces)
```

###

Now that you've seen the different variables in `cces`, `select()` `age`, `state`,  and `gender`

```{r data-I-3, exercise=TRUE, exercise.lines=3}
cces
```

```{r data-I-3-hint, eval=FALSE}
remember to pipe!
```

###

Let's `filter()` our code from the previous question so that we are only looking at rows where `state == "Massachusetts"` and `gender == "Female"`.

```{r data-I-4, exercise=TRUE, exercise.lines=10}


```

```{r data-I-4-hint, eval=FALSE}
remember to use the double ==
```

###

Now use `arrange()` to organize our code by descending order of age.

```{r data-I-5, exercise=TRUE, exercise.lines=10}

```

```{r data-I-5-hint, eval=FALSE}
remember to include desc()
```

###

Great! Now use `summarize()` to find the mean and median ages from our filtered data.

```{r data-I-6, exercise=TRUE, exercise.lines=10}

```

###

Awesome! So let's recap what we just did. We first selected specific variables to focus on and then filtered to narrow down our search. We then arranged by descending order of age. Then, from that data, we found the mean and median age with `summarize()`. Through these steps, we found the mean and median ages of women from Massachusetts in the survey. With these next couple questions, you will be doing this yourself. Find the mean age of liberal men from California:

```{r data-I-7, exercise=TRUE, exercise.lines=10}

```

```{r data-I-7-hint,eval=FALSE}
If some of the values apply to unfamiliar variables, feel free to always take a glimpse() back at the data set
```

###

Did you get 47.2? If so, awesome job! If not, look back at your code. For this next one, find the median age of divorced female Texans who attended "Some College":

```{r data-I-8, exercise=TRUE, exercise.lines=10}

```

###

The correct answer is 56. If you got something different, look back at your code. Great job!

###

For this section, we will be focusing on the data set `nhanes`. `nhanes` is a really big data set and there are many things we can do with its data, but let's say we wanted to make a graph using data on `height` and `weight` from the 200 youngest black males. How would we go about doing this? Well first, we would `select()` the variables we want to focus on, in this case `height`, `weight`, `age`, `race`, and `gender`.  Try doing this below:

```{r data-II-1, exercise=TRUE, exercise.lines=10}


```

###

So what would we do next? We want to narrow down our data to only black males, so let's use `filter()` to create a tibble made up of rows from `nhanes` where `race == "Black"` and `gender == "Male"`. Do this below:

```{r data-II-2, exercise=TRUE, exercise.lines=10}


```

###

Great! So what now? Well, we want to look at the youngest black males. To do this, we would have to `arrange()` by age. Do this below:

```{r data-II-3, exercise=TRUE, exercise.lines=10}


```

###

Nice! Now use `slice()` to isolate the 200 rows with the lowest age value.

```{r data-II-4, exercise=TRUE, exercise.lines=10}


```

```{r data-II-4-hint-1, eval=FALSE}

Because of the way we arranged the data, the 200 rows with the lowest age value would be the first 200

```

```{r data-II-4-hint-2, eval=FALSE}

slice(1:200)

```

###

Awesome! We now have our tibble! Now use `geom_smooth()` to create a graph with `weight` on the x axis and `height` on the y axis.

```{r data-II-5, exercise=TRUE, exercise.lines=10}


```

```{r data-II-5-hint, eval=FALSE}
... %>% ggplot(aes(x = weight, y = height)) + geom_smooth()

```

###

Now we are going to be focusing on the data set `qscores`, which includes data on Harvard courses from the 2018-19 school year. Let's start by grouping `qscores` by `department`.

```{r data-III-1, exercise=TRUE, exercise.lines=3}

```

###

Now use `summarize()` to find the mean rating for each of `department` in our grouped tibble.

```{r data-III-2, exercise=TRUE, exercise.lines=6}

```

###

Nice! Now use `arrange()` to order our data by `desc`ending mean rating.

```{r data-III-3, exercise=TRUE, exercise.lines=6}


```

###

Great! As you can see, the tibble we have just created lists the different departments at Harvard included in `qscores` and their average rating. There's a lot of different things we can do this with this data, but let's say we wanted to make a plot with only the top 10 average rated departments. We would need to make a tibble to do this right? Use `slice()` to create this tibble.

```{r data-III-4, exercise=TRUE, exercise.lines=6}


```

###

Fantastic! Now use this tibble you created to make a bar plot with `department` on the x axis and `mean` on the y axis (notice how are new tibble uses variables not in `qscores`)

```{r data-III-5, exercise=TRUE, exercise.lines=6}


```

###

Awesome! Let's start fresh from the original `qscores` data set again. Word just came in that Harvard is switching to a rating scale out of 10 for the next term! Upper admin wants to be able to compare data from last year to the next term, so use `mutate()` to add the new variable `rating_2` equal to two times the variable `rating` in `new_qscores`. I have started it for you:

```{r data-III-6, exercise=TRUE, exercise.lines=6, eval=FALSE}
new_qscores <- qscores %>%


```

###

Now use `summarize()` to find the standard deviation of `rating_2`

```{r data-III-7, exercise=TRUE, exercise.lines=6, eval=FALSE}
new_qscores <- qscores %>%
  mutate(rating_2 = rating * 2)

new_qscores %>%


```

###

Great! Now let's play around with the `airquality` dataset, which measures different atmospheric measurements in New York. Select `Month`, `Day`, and `Temp` from the dataset.

```{r da-1-2, exercise=TRUE, exercise.lines = 5}
airquality
```

###

Now, let's use `glimpse()` on our data set to take a good look at it.

```{r da-1-3, exercise=TRUE, exercise.lines = 5}
airquality %>%
  select(Month, Day, Temp)
```

###

Great, now, use what you've learned from the textbook to calculate the average of the `Temp` variable. Let's call this value `average`.

```{r da-1-4, exercise=TRUE, exercise.lines = 5}
airquality %>%
  select(Month, Day, Temp)
```

###

Nice job! Finally, use everything you've learned so far to calculate the maximum Temp value of every month. We can call this variable `maxTemp`. Then, sort them from the highest value to the lowest (descending order).

```{r da-1-5-hint, eval=FALSE}
You will use group_by(...) and arrange(desc()). If you are having more trouble, refer to the textbook.
```

```{r da-1-5, exercise=TRUE, exercise.lines = 5, eval=FALSE}
airquality %>%
  select(Month, Day, Temp)
```

###

Let's do some data wrangling with the `mpg` tibble, which contains fuel efficiency data on different types of cars. Let's start by loading the data set, and using `select()` to pick out the `cty` and `class` variables.

```{r da-2-1, exercise=TRUE, exercise.lines = 5}

```

###

Let's say, for whatever reason, we wanted to remove all cars with their `manufacturer == "chevrolet"` from our data. We could do this using the `filter()` function and the `!=` symbol.  Try it!

Remember that this must be done BEFORE we use `select()`, which removes the `manufacturer` column altogether.

```{r da-2-2, exercise=TRUE, exercise.lines = 5}

```

```{r da-2-2-hint, eval=FALSE}
mpg %>%
  filter(...) %>%
  select(...)
```

###

Nice. Now, let's use `group_by()` to split up our data by `class`.

```{r da-2-3, exercise=TRUE, exercise.lines = 5}

```

###

Good stuff. Now, let's use `arrange()` to sort our `cty` values from lowest to highest within their respective classes.

Note that if you want to sort your data from highest to lowest, you can use `arrange(desc(...))`.

```{r da-2-4, exercise=TRUE, exercise.lines = 5}

```

###

Nice work. Now, let's use `summarize()` to calculate the `mean` of the `cty` values in each class. We can save our results as a new variable, called `ctyAverage`

```{r da-2-5, exercise=TRUE, exercise.lines = 5}

```

###

Good stuff. But let's say we're experimenting with a new type of gasoline that's twice as efficient as the traditional kind that the data in `mpg` was recorded with.

We could calculate the predicted City MPG with this new fuel using `mutate()`. Use `mutate()` to create a new variable, `ctyAverage2`, that's 2x `ctyAverage`.

```{r da-2-6, exercise=TRUE, exercise.lines = 5}

```

<!-- ### JSE - seems like too hard of a question... -->

<!-- Excellent work. Now, use what you've learned about data wrangling to replicate the result blow. -->

<!-- Information from the `compact` class in not in the final data set. -->

<!-- ```{r} -->
<!-- mpg %>% -->
<!--   filter(class != "compact") %>% -->
<!--   select(displ, manufacturer) %>% -->
<!--   group_by(manufacturer) %>% -->
<!--   summarize(displMedian = median(displ)) %>% -->
<!--   arrange(desc(displMedian)) -->
<!-- ``` -->

<!-- ```{r da-2-7, exercise=TRUE, exercise.lines = 5} -->

<!-- ``` -->

###

Let's do some data wrangling with the `qscores` tibble, which contains data from student course evaluations at Harvard.

Begin by using `select()` to pick out the `term`, `rating`, and `enrollment` variables.

```{r da-3-1, exercise=TRUE, exercise.lines = 5}

```

###

Nice. Let's use `filter()` so we only account for classes with a rating above 3.0.

```{r da-3-2, exercise=TRUE, exercise.lines = 5}

```

###

Good stuff. Now, let's use `group_by()` to divide our data by `term`.

```{r da-3-3, exercise=TRUE, exercise.lines = 5}

```

###

Nice. Let's say our goal was to calculate the average number of students in a Harvard class for each term a month into the term. But let's not take the average yet, there are still some factors we haven't accounted for yet.

Let's say on average, one tenth of all students drop a class by one month into the term, and two students are absent per class. We can calculate this by using `mutate()` to multiply `enrollment` by 9/10 and then subtract 2. Try it!

```{r da-3-4, exercise=TRUE, exercise.lines = 5}

```

###

Great. Now we can use `summarize()` to find the `mean` of `enrollment`. We can call this new variable `avgEnrollment`.

```{r da-3-5, exercise=TRUE, exercise.lines = 5}

```

###

Nice work. Let's also use `summarize()` to find the `min()` and `max()` of enrollment for each term. We can call these new variables `minEnrollment` and `maxEnrollment` respectively.

```{r da-3-6, exercise=TRUE, exercise.lines = 5}

```

<!-- ### JSE - also seems like too hard of a question... -->

<!-- Well done. Now, use what you've learned about data wrangling to recreate the dataset below. -->

<!-- The dataset only takes into account classes with an enrollment of at least 25. To calculate the devation from the median of a variable, use `mad()`, which stands for Median Absolute Deviation -->

<!-- ```{r} -->
<!-- qscores %>% -->
<!--   select(rating, department, enrollment) %>% -->
<!--   filter(enrollment > 25) %>% -->
<!--   group_by(department) %>% -->
<!--   summarise(medianRating = median(rating), -->
<!--             deviation = mad(rating)) -->
<!-- ``` -->

<!-- ```{r da-3-7, exercise=TRUE, exercise.lines = 5} -->

<!-- ``` -->

## Submit

Congrats on finishing your first Gov 50 tutorial! You're on your way to being a master in data visualization and wrangling! :)

```{r context="setup"}
submission_ui
```

```{r context="server"}
submission_server()
```
